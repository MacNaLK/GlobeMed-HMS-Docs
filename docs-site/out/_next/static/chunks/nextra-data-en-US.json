{"/appointment-scheduling":{"title":"Appointment Scheduling","data":{"":"Document: Part B AnalysisPattern: Mediator PatternModule: Appointment Scheduling SystemAuthor: Ishara Lakshitha","table-of-contents#Table of Contents":"","1-overview--problem-statement#1. Overview & Problem Statement":"","healthcare-domain-problems-addressed#Healthcare Domain Problems Addressed":"Problem 1: Complex Scheduling Logic\nMultiple entities involved: Patients, Doctors, Appointments, Schedules\nComplex business rules for conflict detection\nTime slot validation with 30-minute appointment windows\nIntegration with database persistence layer\nProblem 2: Tight Coupling Between Components\nWithout mediation, each component would need direct references to others\nPatient scheduling would require knowledge of Doctor availability\nDoctor objects would need to manage their own appointment conflicts\nDatabase operations scattered across multiple classes\nProblem 3: Centralized Business Rule Management\nAppointment validation rules need consistent application\nConflict detection algorithms require centralized logic\nStatus management and workflow coordination\nError handling and feedback messaging","solution-approach#Solution Approach":"The Mediator Pattern implementation centralizes all complex scheduling interactions through the AppointmentScheduler class, which acts as the mediator between:\nPatient booking requests\nDoctor availability checking\nAppointment conflict detection\nDatabase persistence operations","2-mediator-pattern-implementation#2. Mediator Pattern Implementation":"","21-pattern-participants#2.1 Pattern Participants":"","mediator-interface-implicit#Mediator Interface (Implicit)":"// The mediator responsibilities are fulfilled by AppointmentScheduler\n// Could be made explicit with an interface, but concrete implementation suffices\npublic interface SchedulingMediator {\n    String bookAppointment(String patientId, Doctor doctor,\n                          LocalDateTime requestedDateTime, String reason, String doctorNotes);\n}","concrete-mediator#Concrete Mediator":"/**\n * The Mediator. It handles the complex logic of scheduling,\n * checking for conflicts, and coordinating between the database and the request.\n */\npublic class AppointmentScheduler {\n    private final SchedulingDAO schedulingDAO;\n    public AppointmentScheduler() {\n        this.schedulingDAO = new SchedulingDAO();\n    }\n    /**\n     * Central coordination method for appointment booking\n     * Encapsulates all complex scheduling logic\n     */\n    public String bookAppointment(String patientId, Doctor doctor,\n                                 LocalDateTime requestedDateTime, String reason,\n                                 String doctorNotes) {\n        // Step 1: Retrieve existing appointments for conflict checking\n        List<Appointment> existingAppointments =\n            schedulingDAO.getAppointmentsForDoctorOnDate(doctor.getDoctorId(),\n                                                        requestedDateTime.toLocalDate());\n        // Step 2: Apply business rules for conflict detection\n        for (Appointment existing : existingAppointments) {\n            LocalDateTime existingStart = existing.getAppointmentDateTime();\n            // 30-minute conflict rule implementation\n            if (requestedDateTime.isAfter(existingStart.minusMinutes(30)) &&\n                requestedDateTime.isBefore(existingStart.plusMinutes(30))) {\n                return \"Booking failed: Time slot conflicts with an existing appointment (30-min rule).\";\n            }\n        }\n        // Step 3: Create and persist new appointment\n        Appointment newAppointment = new Appointment(patientId, doctor.getDoctorId(),\n                                                    requestedDateTime, reason);\n        newAppointment.setDoctorNotes(doctorNotes);\n        boolean success = schedulingDAO.createAppointment(newAppointment);\n        return success ? \"Appointment booked successfully!\" :\n                        \"Booking failed: Could not save to database.\";\n    }\n}","colleague-classes#Colleague Classes":"Appointment (Domain Entity)\npublic class Appointment implements Visitable {\n    private int appointmentId;\n    private String patientId;\n    private String doctorId;\n    private LocalDateTime appointmentDateTime;\n    private String reason;\n    private String status;\n    private String doctorNotes;\n    private LocalDateTime lastUpdated;\n    private String lastUpdatedBy;\n    public Appointment(String patientId, String doctorId,\n                      LocalDateTime appointmentDateTime, String reason) {\n        this.patientId = patientId;\n        this.doctorId = doctorId;\n        this.appointmentDateTime = appointmentDateTime;\n        this.reason = reason;\n        this.status = \"Scheduled\"; // Default status\n        this.doctorNotes = \"\";\n        this.lastUpdated = LocalDateTime.now();\n        this.lastUpdatedBy = \"system\";\n    }\n    // Getters and setters...\n}\nDoctor (Domain Entity)\npublic class Doctor {\n    private String doctorId;\n    private String fullName;\n    private String specialty;\n    public Doctor(String doctorId, String fullName, String specialty) {\n        this.doctorId = doctorId;\n        this.fullName = fullName;\n        this.specialty = specialty;\n    }\n    // Getters and setters...\n}\nSchedulingDAO (Data Access Layer)\npublic class SchedulingDAO {\n    public List<Appointment> getAppointmentsForDoctorOnDate(String doctorId, LocalDate date) {\n        // Database query implementation\n    }\n    public boolean createAppointment(Appointment appointment) {\n        // Database persistence implementation\n    }\n    public List<Doctor> getAllDoctors() {\n        // Doctor retrieval implementation\n    }\n}","3-uml-class-diagrams#3. UML Class Diagrams":"","30-comprehensive-diagram#3.0 Comprehensive Diagram":"(You can find the High Res images in the Github Project Repo)","31-mediator-pattern-structure#3.1 Mediator Pattern Structure":"┌─────────────────────────────────────┐\n│      AppointmentController          │\n│         (Client/Colleague)          │\n├─────────────────────────────────────┤\n│ - scheduler: AppointmentScheduler   │\n│ - dao: SchedulingDAO                │\n│ - view: AppointmentPanel            │\n├─────────────────────────────────────┤\n│ + bookNewAppointment(): void        │\n│ + viewSchedule(): void              │\n│ + cancelAppointment(): void         │\n└─────────────────────────────────────┘\n                    │\n                    │ uses\n                    ▼\n┌─────────────────────────────────────┐\n│     AppointmentScheduler            │\n│         (Mediator)                  │\n├─────────────────────────────────────┤\n│ - schedulingDAO: SchedulingDAO      │\n├─────────────────────────────────────┤\n│ + bookAppointment(): String         │\n└─────────────────────────────────────┘\n                    │\n                    │ coordinates\n                    ▼\n┌─────────────────────────────────────┐    ┌─────────────────────────────────────┐\n│         Appointment                 │    │            Doctor                   │\n│       (Colleague)                   │    │          (Colleague)                │\n├─────────────────────────────────────┤    ├─────────────────────────────────────┤\n│ - appointmentId: int                │    │ - doctorId: String                  │\n│ - patientId: String                 │    │ - fullName: String                  │\n│ - doctorId: String                  │    │ - specialty: String                 │\n│ - appointmentDateTime: LocalDateTime│    ├─────────────────────────────────────┤\n│ - reason: String                    │    │ + getDoctorId(): String             │\n│ - status: String                    │    │ + getFullName(): String             │\n│ - doctorNotes: String               │    │ + getSpecialty(): String            │\n├─────────────────────────────────────┤    └─────────────────────────────────────┘\n│ + getAppointmentDateTime(): LocalDT │\n│ + setStatus(status): void           │\n│ + setDoctorNotes(notes): void       │\n└─────────────────────────────────────┘\n                    ▲\n                    │ manages\n                    │\n┌─────────────────────────────────────┐\n│         SchedulingDAO               │\n│       (Data Access)                 │\n├─────────────────────────────────────┤\n│ + getAppointmentsForDoctorOnDate()  │\n│ + createAppointment(): boolean      │\n│ + updateAppointment(): boolean      │\n│ + getAllDoctors(): List<Doctor>     │\n└─────────────────────────────────────┘","32-interaction-flow-diagram#3.2 Interaction Flow Diagram":"Client Request → Controller → Mediator → Database/Entities → Response\nAppointmentController.bookNewAppointment()\n            │\n            ▼\nAppointmentScheduler.bookAppointment()\n            │\n            ├─→ SchedulingDAO.getAppointmentsForDoctorOnDate()\n            │                    │\n            │                    ▼\n            │            [Conflict Detection Logic]\n            │                    │\n            ├─→ new Appointment()\n            │                    │\n            └─→ SchedulingDAO.createAppointment()\n                                │\n                                ▼\n                         [Success/Failure Response]","4-detailed-code-analysis#4. Detailed Code Analysis":"","41-conflict-detection-algorithm#4.1 Conflict Detection Algorithm":"/**\n * Core business logic: 30-minute appointment window conflict detection\n * This algorithm prevents overlapping appointments by ensuring a 30-minute\n * buffer around each existing appointment.\n */\npublic String bookAppointment(String patientId, Doctor doctor,\n                             LocalDateTime requestedDateTime, String reason,\n                             String doctorNotes) {\n    // Retrieve all appointments for the doctor on the requested date\n    List<Appointment> existingAppointments =\n        schedulingDAO.getAppointmentsForDoctorOnDate(doctor.getDoctorId(),\n                                                    requestedDateTime.toLocalDate());\n    // Apply 30-minute conflict rule\n    for (Appointment existing : existingAppointments) {\n        LocalDateTime existingStart = existing.getAppointmentDateTime();\n        /*\n         * Conflict scenarios:\n         * - Existing at 10:00, Requested at 10:15 → CONFLICT (within 30 min)\n         * - Existing at 10:00, Requested at 09:45 → CONFLICT (within 30 min)\n         * - Existing at 10:00, Requested at 10:30 → NO CONFLICT (exactly 30 min)\n         * - Existing at 10:00, Requested at 09:30 → NO CONFLICT (exactly 30 min)\n         */\n        if (requestedDateTime.isAfter(existingStart.minusMinutes(30)) &&\n            requestedDateTime.isBefore(existingStart.plusMinutes(30))) {\n            return \"Booking failed: Time slot conflicts with an existing appointment (30-min rule).\";\n        }\n    }\n    // No conflicts found - proceed with booking\n    Appointment newAppointment = new Appointment(patientId, doctor.getDoctorId(),\n                                                requestedDateTime, reason);\n    newAppointment.setDoctorNotes(doctorNotes);\n    boolean success = schedulingDAO.createAppointment(newAppointment);\n    return success ? \"Appointment booked successfully!\" :\n                    \"Booking failed: Could not save to database.\";\n}","42-data-access-coordination#4.2 Data Access Coordination":"/**\n * The mediator coordinates with the DAO layer to retrieve necessary data\n * for conflict checking without exposing database operations to the client\n */\npublic List<Appointment> getAppointmentsForDoctorOnDate(String doctorId, LocalDate date) {\n    List<Appointment> appointments = new ArrayList<>();\n    String sql = \"SELECT * FROM appointments WHERE doctor_id = ? AND DATE(appointment_datetime) = ?\";\n    try (Connection conn = DatabaseManager.getConnection();\n         PreparedStatement pstmt = conn.prepareStatement(sql)) {\n        pstmt.setString(1, doctorId);\n        pstmt.setDate(2, Date.valueOf(date));\n        ResultSet rs = pstmt.executeQuery();\n        while (rs.next()) {\n            Appointment appt = new Appointment(\n                rs.getString(\"patient_id\"),\n                rs.getString(\"doctor_id\"),\n                rs.getTimestamp(\"appointment_datetime\").toLocalDateTime(),\n                rs.getString(\"reason\")\n            );\n            appt.setAppointmentId(rs.getInt(\"appointment_id\"));\n            appt.setStatus(rs.getString(\"status\"));\n            appt.setDoctorNotes(rs.getString(\"doctor_notes\"));\n            appointments.add(appt);\n        }\n    } catch (SQLException e) {\n        System.err.println(\"Error fetching appointments for doctor \" +\n                          doctorId + \" on \" + date + \": \" + e.getMessage());\n    }\n    return appointments;\n}","43-object-creation-and-state-management#4.3 Object Creation and State Management":"/**\n * The mediator handles object creation and initial state setup\n * ensuring consistent object initialization across the system\n */\nAppointment newAppointment = new Appointment(patientId, doctor.getDoctorId(),\n                                           requestedDateTime, reason);\n// Set additional properties through mediator logic\nnewAppointment.setDoctorNotes(doctorNotes);\n// Status is automatically set to \"Scheduled\" in constructor\n// lastUpdated and lastUpdatedBy are set automatically\n// Persistence is handled through the mediator's DAO coordination\nboolean success = schedulingDAO.createAppointment(newAppointment);","5-complex-interaction-management#5. Complex Interaction Management":"","51-multi-step-workflow-coordination#5.1 Multi-Step Workflow Coordination":"The mediator manages a complex workflow that involves multiple steps:\n/**\n * Complete appointment booking workflow managed by the mediator:\n * 1. Data Retrieval\n * 2. Business Rule Validation\n * 3. Object Creation\n * 4. Persistence\n * 5. Response Generation\n */\npublic String bookAppointment(...) {\n    // Step 1: Data Retrieval\n    List<Appointment> existingAppointments = schedulingDAO.getAppointmentsForDoctorOnDate(...);\n    // Step 2: Business Rule Validation\n    for (Appointment existing : existingAppointments) {\n        if (hasConflict(requestedDateTime, existing.getAppointmentDateTime())) {\n            return generateConflictMessage();\n        }\n    }\n    // Step 3: Object Creation\n    Appointment newAppointment = createAppointment(...);\n    // Step 4: Persistence\n    boolean success = schedulingDAO.createAppointment(newAppointment);\n    // Step 5: Response Generation\n    return generateResponseMessage(success);\n}","52-integration-with-controller-layer#5.2 Integration with Controller Layer":"/**\n * AppointmentController delegates complex scheduling to the mediator\n * while handling UI concerns and user permissions\n */\npublic class AppointmentController {\n    private final AppointmentScheduler scheduler; // Mediator instance\n    private void bookNewAppointment() {\n        // UI validation and data collection\n        String patientId = view.patientIdField.getText().trim();\n        String reason = view.reasonField.getText().trim();\n        String doctorNotes = view.getDoctorNotesText();\n        // Permission checking\n        if (!currentUser.hasPermission(\"can_book_appointment\")) {\n            showPermissionError();\n            return;\n        }\n        // Doctor selection logic\n        Doctor selectedDoctor = getSelectedDoctor();\n        LocalDateTime requestedDateTime = getRequestedDateTime();\n        // Delegate to mediator for complex scheduling logic\n        String resultMessage = scheduler.bookAppointment(\n            patientId, selectedDoctor, requestedDateTime, reason, doctorNotes\n        );\n        // Handle response and update UI\n        JOptionPane.showMessageDialog(view, resultMessage +\n            \"\\\\nBooked by: \" + currentUser.getUsername());\n        viewSchedule(); // Refresh display\n        view.clearBookingFormFields();\n    }\n}","53-database-transaction-coordination#5.3 Database Transaction Coordination":"/**\n * The mediator can coordinate database transactions across multiple operations\n * ensuring data consistency for complex scheduling scenarios\n */\npublic boolean createAppointment(Appointment appointment) {\n    String sql = \"INSERT INTO appointments (patient_id, doctor_id, appointment_datetime, \" +\n                \"reason, doctor_notes, status) VALUES (?, ?, ?, ?, ?, ?)\";\n    try (Connection conn = DatabaseManager.getConnection();\n         PreparedStatement pstmt = conn.prepareStatement(sql)) {\n        pstmt.setString(1, appointment.getPatientId());\n        pstmt.setString(2, appointment.getDoctorId());\n        pstmt.setTimestamp(3, Timestamp.valueOf(appointment.getAppointmentDateTime()));\n        pstmt.setString(4, appointment.getReason());\n        pstmt.setString(5, appointment.getDoctorNotes());\n        pstmt.setString(6, appointment.getStatus() != null ?\n                           appointment.getStatus() : \"Scheduled\");\n        boolean success = pstmt.executeUpdate() > 0;\n        if (success) {\n            System.out.println(\"SUCCESS: Created appointment for patient \" +\n                             appointment.getPatientId() + \" with doctor \" +\n                             appointment.getDoctorId());\n        }\n        return success;\n    } catch (SQLException e) {\n        System.err.println(\"ERROR: Error creating appointment: \" + e.getMessage());\n        return false;\n    }\n}","6-usage-scenarios#6. Usage Scenarios":"","61-scenario-1-successful-appointment-booking#6.1 Scenario 1: Successful Appointment Booking":"// Setup\nAppointmentScheduler scheduler = new AppointmentScheduler();\nDoctor doctor = new Doctor(\"D001\", \"Dr. Smith\", \"Cardiology\");\nLocalDateTime requestTime = LocalDateTime.of(2025, 8, 31, 14, 0); // 2:00 PM\n// Execution\nString result = scheduler.bookAppointment(\n    \"P001\",           // Patient ID\n    doctor,           // Doctor object\n    requestTime,      // Requested time\n    \"Chest pain\",     // Reason\n    \"Follow-up needed\" // Doctor notes\n);\n// Expected Result\nassertEquals(\"Appointment booked successfully!\", result);","62-scenario-2-conflict-detection#6.2 Scenario 2: Conflict Detection":"// Setup - Existing appointment at 2:00 PM\nAppointment existing = new Appointment(\"P002\", \"D001\",\n    LocalDateTime.of(2025, 8, 31, 14, 0), \"Regular checkup\");\n// Assume existing appointment is already in database\n// Attempt to book at 2:15 PM (within 30-minute window)\nString result = scheduler.bookAppointment(\n    \"P003\", doctor,\n    LocalDateTime.of(2025, 8, 31, 14, 15),\n    \"Consultation\", \"\"\n);\n// Expected Result\nassertTrue(result.contains(\"conflicts with an existing appointment\"));","63-scenario-3-multiple-doctor-coordination#6.3 Scenario 3: Multiple Doctor Coordination":"// Different doctors can have appointments at the same time\nDoctor doctor1 = new Doctor(\"D001\", \"Dr. Smith\", \"Cardiology\");\nDoctor doctor2 = new Doctor(\"D002\", \"Dr. Jones\", \"Neurology\");\nLocalDateTime sameTime = LocalDateTime.of(2025, 8, 31, 14, 0);\n// Both should succeed - no conflict between different doctors\nString result1 = scheduler.bookAppointment(\"P001\", doctor1, sameTime, \"Reason1\", \"\");\nString result2 = scheduler.bookAppointment(\"P002\", doctor2, sameTime, \"Reason2\", \"\");\nassertEquals(\"Appointment booked successfully!\", result1);\nassertEquals(\"Appointment booked successfully!\", result2);","64-scenario-4-edge-case---exact-30-minute-boundary#6.4 Scenario 4: Edge Case - Exact 30-Minute Boundary":"// Existing appointment at 2:00 PM\nLocalDateTime existingTime = LocalDateTime.of(2025, 8, 31, 14, 0);\n// New appointment at 2:30 PM (exactly 30 minutes later)\nLocalDateTime newTime = LocalDateTime.of(2025, 8, 31, 14, 30);\nString result = scheduler.bookAppointment(\"P001\", doctor, newTime, \"Checkup\", \"\");\n// Should succeed - exactly 30 minutes is allowed\nassertEquals(\"Appointment booked successfully!\", result);","7-benefits--trade-offs#7. Benefits & Trade-offs":"","71-mediator-pattern-benefits#7.1 Mediator Pattern Benefits":"Reduced Coupling\nColleague objects don't need direct references to each other\nAppointmentController doesn't need to know about conflict detection logic\nDoctor objects don't manage their own scheduling conflicts\nDatabase operations are centralized and abstracted\nCentralized Control\nAll scheduling business rules in one location\nConsistent conflict detection across the application\nEasy to modify scheduling algorithms without affecting multiple classes\nSingle point of control for appointment workflow\nSimplified Object Protocols\nComplex many-to-many interactions become one-to-many with mediator\nClear separation of concerns between UI, business logic, and data access\nStandardized communication patterns through mediator interface\nEnhanced Maintainability\nBusiness rule changes require modifications in only one place\nEasy to add new scheduling constraints or validation rules\nCentralized error handling and logging\nClear audit trail for all scheduling operations","72-specific-healthcare-domain-benefits#7.2 Specific Healthcare Domain Benefits":"Patient Safety\nConsistent conflict detection prevents double-booking\nCentralized validation ensures all business rules are applied\nAudit trail for all scheduling decisions\nOperational Efficiency\nStreamlined booking process through centralized coordination\nConsistent error messages and user feedback\nScalable approach for complex scheduling scenarios\nSystem Integration\nClean integration points with external systems\nCentralized database transaction management\nConsistent data validation and persistence","73-trade-offs-and-considerations#7.3 Trade-offs and Considerations":"Mediator Complexity\nThe mediator can become complex as it centralizes all coordination logic\nRisk of creating a \"god object\" if not properly designed\nNeed to balance centralization with appropriate delegation\nPerformance Considerations\nAdditional layer of indirection may impact performance\nDatabase queries centralized through mediator may need optimization\nCaching strategies may be needed for frequently accessed data\nTesting Complexity\nMediator requires comprehensive testing of all interaction scenarios\nMock objects needed for testing isolated mediator behavior\nIntegration testing becomes critical for validating complete workflows\nSingle Point of Failure\nMediator becomes critical component - failures affect entire scheduling system\nNeed for robust error handling and recovery mechanisms\nMonitoring and alerting for mediator health becomes important","8-testing--validation#8. Testing & Validation":"","81-unit-testing-the-mediator#8.1 Unit Testing the Mediator":"@Test\npublic void testSuccessfulAppointmentBooking() {\n    // Arrange\n    AppointmentScheduler scheduler = new AppointmentScheduler();\n    Doctor doctor = new Doctor(\"D001\", \"Dr. Test\", \"General\");\n    LocalDateTime appointmentTime = LocalDateTime.of(2025, 9, 1, 10, 0);\n    // Act\n    String result = scheduler.bookAppointment(\n        \"P001\", doctor, appointmentTime, \"Check-up\", \"Regular visit\"\n    );\n    // Assert\n    assertEquals(\"Appointment booked successfully!\", result);\n}\n@Test\npublic void testConflictDetection() {\n    // Arrange - Create existing appointment\n    AppointmentScheduler scheduler = new AppointmentScheduler();\n    Doctor doctor = new Doctor(\"D001\", \"Dr. Test\", \"General\");\n    LocalDateTime existingTime = LocalDateTime.of(2025, 9, 1, 10, 0);\n    LocalDateTime conflictTime = LocalDateTime.of(2025, 9, 1, 10, 15);\n    // Create first appointment\n    scheduler.bookAppointment(\"P001\", doctor, existingTime, \"First\", \"\");\n    // Act - Try to book conflicting appointment\n    String result = scheduler.bookAppointment(\"P002\", doctor, conflictTime, \"Second\", \"\");\n    // Assert\n    assertTrue(result.contains(\"conflicts with an existing appointment\"));\n}\n@Test\npublic void testBoundaryConditions() {\n    AppointmentScheduler scheduler = new AppointmentScheduler();\n    Doctor doctor = new Doctor(\"D001\", \"Dr. Test\", \"General\");\n    // Test exact 30-minute boundary\n    LocalDateTime baseTime = LocalDateTime.of(2025, 9, 1, 10, 0);\n    LocalDateTime boundaryTime = baseTime.plusMinutes(30);\n    scheduler.bookAppointment(\"P001\", doctor, baseTime, \"First\", \"\");\n    String result = scheduler.bookAppointment(\"P002\", doctor, boundaryTime, \"Second\", \"\");\n    assertEquals(\"Appointment booked successfully!\", result);\n}","82-integration-testing#8.2 Integration Testing":"@Test\npublic void testCompleteSchedulingWorkflow() {\n    // Test complete workflow from controller through mediator to database\n    AppointmentController controller = new AppointmentController(view, mainFrame, user);\n    // Simulate user input\n    view.patientIdField.setText(\"P001\");\n    view.reasonField.setText(\"Annual checkup\");\n    // Simulate doctor selection\n    Doctor testDoctor = new Doctor(\"D001\", \"Dr. Test\", \"General\");\n    view.selectDoctor(testDoctor);\n    // Simulate date/time selection\n    view.setDateTime(LocalDateTime.of(2025, 9, 1, 14, 0));\n    // Execute booking\n    controller.bookNewAppointment();\n    // Verify appointment was created in database\n    List<Appointment> appointments = dao.getAppointmentsForDoctorOnDate(\n        \"D001\", LocalDate.of(2025, 9, 1)\n    );\n    assertEquals(1, appointments.size());\n    assertEquals(\"P001\", appointments.get(0).getPatientId());\n}","83-performance-testing#8.3 Performance Testing":"@Test\npublic void testConcurrentBookingScenarios() {\n    AppointmentScheduler scheduler = new AppointmentScheduler();\n    Doctor doctor = new Doctor(\"D001\", \"Dr. Test\", \"General\");\n    ExecutorService executor = Executors.newFixedThreadPool(10);\n    List<Future<String>> futures = new ArrayList<>();\n    // Submit multiple concurrent booking requests\n    for (int i = 0; i < 10; i++) {\n        final int patientNum = i;\n        Future<String> future = executor.submit(() -> {\n            return scheduler.bookAppointment(\n                \"P\" + String.format(\"%03d\", patientNum),\n                doctor,\n                LocalDateTime.of(2025, 9, 1, 10, patientNum * 5), // 5-minute intervals\n                \"Test appointment \" + patientNum,\n                \"\"\n            );\n        });\n        futures.add(future);\n    }\n    // Verify all bookings completed successfully\n    for (Future<String> future : futures) {\n        String result = future.get();\n        assertEquals(\"Appointment booked successfully!\", result);\n    }\n}","84-error-handling-testing#8.4 Error Handling Testing":"@Test\npublic void testDatabaseFailureHandling() {\n    // Test mediator behavior when database is unavailable\n    AppointmentScheduler scheduler = new AppointmentScheduler();\n    // Simulate database failure by using invalid connection\n    // This would require dependency injection or mocking for proper testing\n    String result = scheduler.bookAppointment(\n        \"P001\", doctor, appointmentTime, \"Test\", \"\"\n    );\n    assertEquals(\"Booking failed: Could not save to database.\", result);\n}","conclusion#Conclusion":"The Mediator pattern implementation in the appointment scheduling system demonstrates a sophisticated approach to managing complex interactions in healthcare software. The AppointmentScheduler class effectively centralizes scheduling logic while maintaining loose coupling between system components.","key-achievements#Key Achievements":"Complexity Management: Successfully encapsulates complex scheduling business rules in a single, manageable component\nConflict Resolution: Implements robust 30-minute conflict detection algorithm with clear boundary conditions\nIntegration Coordination: Seamlessly coordinates between UI controllers, domain objects, and data access layers\nMaintainability: Provides a single point of control for scheduling modifications and enhancements\nHealthcare Compliance: Ensures consistent application of scheduling rules critical for patient care coordination","real-world-impact#Real-World Impact":"The mediator pattern proves particularly valuable in healthcare contexts where:\nPatient Safety depends on accurate scheduling without conflicts\nOperational Efficiency requires streamlined booking processes\nSystem Integration needs clean interfaces between complex subsystems\nRegulatory Compliance demands consistent business rule application\nThe implementation successfully addresses the challenge of managing complex interactions while maintaining clean architecture principles and providing a foundation for future enhancements to the scheduling system.Document Status: Part B CompleteNext: Part C - Billing & Insurance Claims (Chain of Responsibility Pattern)"}},"/billing-insurance":{"title":"Billing & Insurance Claims","data":{"":"Document: Part C AnalysisPattern: Chain of Responsibility PatternModule: Billing and Insurance Processing SystemAuthor: Ishara Lakshitha","table-of-contents#Table of Contents":"","1-overview--problem-statement#1. Overview & Problem Statement":"","healthcare-domain-problems-addressed#Healthcare Domain Problems Addressed":"Problem 1: Complex Billing Workflow\nMedical billing involves multiple sequential processing steps\nEach step has specific validation rules and business logic\nNeed flexible pipeline that can handle various billing scenarios\nDifferent types of bills may require different processing paths\nProblem 2: Insurance Claim Processing Complexity\nInsurance processing depends on patient coverage details\nMultiple insurance plans with different coverage percentages\nNeed to calculate patient responsibility after insurance payments\nComplex rules for co-pays, deductibles, and coverage limits\nProblem 3: Extensible Processing Pipeline\nHealthcare regulations change frequently requiring new processing steps\nNeed ability to add/remove processing handlers without affecting existing code\nDifferent healthcare providers may have different billing workflows\nMust maintain audit trail throughout the entire process","solution-approach#Solution Approach":"The Chain of Responsibility Pattern creates a flexible processing pipeline where each handler specializes in one aspect of billing:\nValidationHandler: Ensures bill data integrity and basic validation\nInsuranceHandler: Processes insurance claims and calculates coverage\nFinalBillingHandler: Determines final amounts and persists to database","2-chain-of-responsibility-implementation#2. Chain of Responsibility Implementation":"","21-pattern-participants#2.1 Pattern Participants":"","handler-interface#Handler Interface":"/**\n * The Handler interface declares a method for building the chain of handlers.\n * It also declares a method for executing a request.\n */\npublic interface BillingHandler {\n    /**\n     * Sets the next handler in the chain.\n     * @param next The next handler to be called.\n     */\n    void setNext(BillingHandler next);\n    /**\n     * Processes the given medical bill.\n     * @param request The bill processing request containing bill and patient data.\n     * @return true if the processing can continue, false if the chain should stop.\n     */\n    boolean processBill(BillProcessingRequest request);\n}","request-object#Request Object":"/**\n * Encapsulates all data needed for bill processing through the chain\n */\npublic class BillProcessingRequest {\n    private final MedicalBill bill;\n    private final PatientRecord patient;\n    public BillProcessingRequest(MedicalBill bill, PatientRecord patient) {\n        this.bill = bill;\n        this.patient = patient;\n    }\n    public MedicalBill getBill() { return bill; }\n    public PatientRecord getPatient() { return patient; }\n}","concrete-handler-1-validationhandler#Concrete Handler 1: ValidationHandler":"/**\n * A concrete handler that performs basic validation on the bill.\n */\npublic class ValidationHandler implements BillingHandler {\n    private BillingHandler next;\n    @Override\n    public void setNext(BillingHandler next) {\n        this.next = next;\n    }\n    @Override\n    public boolean processBill(BillProcessingRequest request) {\n        MedicalBill bill = request.getBill();\n        System.out.println(\"ValidationHandler: Checking bill for patient \" + bill.getPatientId());\n        // Rule 1: Amount must be greater than zero\n        if (bill.getAmount() <= 0) {\n            bill.setStatus(\"Rejected: Invalid Amount\");\n            bill.addLog(\"Validation Failed: Bill amount must be positive.\");\n            System.out.println(\"Validation Failed: Amount is not positive.\");\n            return false; // Stop the chain\n        }\n        // Rule 2: Patient ID must not be empty\n        if (bill.getPatientId() == null || bill.getPatientId().trim().isEmpty()) {\n            bill.setStatus(\"Rejected: Missing Patient ID\");\n            bill.addLog(\"Validation Failed: Patient ID is required.\");\n            System.out.println(\"Validation Failed: Patient ID is missing.\");\n            return false; // Stop the chain\n        }\n        // If validation passes\n        bill.setStatus(\"Validated\");\n        bill.addLog(\"Bill passed initial validation.\");\n        System.out.println(\"Validation successful.\");\n        // Pass to the next handler if it exists\n        if (next != null) {\n            return next.processBill(request);\n        }\n        return true; // End of this path in the chain\n    }\n}","concrete-handler-2-insurancehandler#Concrete Handler 2: InsuranceHandler":"/**\n * Handles insurance claim processing and coverage calculations\n */\npublic class InsuranceHandler implements BillingHandler {\n    private BillingHandler next;\n    @Override\n    public void setNext(BillingHandler next) {\n        this.next = next;\n    }\n    @Override\n    public boolean processBill(BillProcessingRequest request) {\n        MedicalBill bill = request.getBill();\n        PatientRecord patient = request.getPatient();\n        InsurancePlan plan = patient.getInsurancePlan();\n        System.out.println(\"InsuranceHandler: Checking patient \" + patient.getPatientId());\n        if (plan != null) {\n            // Store the insurance plan on the bill for reference\n            bill.setAppliedInsurancePlan(plan);\n            // Calculate insurance coverage\n            double coveragePercent = plan.getCoveragePercent();\n            double amountToCover = bill.getAmount() * (coveragePercent / 100.0);\n            // Apply insurance payment\n            bill.applyInsurancePayment(amountToCover);\n            bill.setStatus(\"Insurance Processed\");\n            bill.addLog(String.format(\"Insurance claim processed for policy %s (%.0f%%). Covered: $%.2f\",\n                    plan.getPlanName(), coveragePercent, amountToCover));\n            System.out.println(\"Insurance processed for \" + plan.getPlanName());\n        } else {\n            bill.addLog(\"No insurance on file. Skipping claim processing.\");\n            System.out.println(\"No insurance found.\");\n        }\n        // Continue to next handler\n        if (next != null) {\n            return next.processBill(request);\n        }\n        return true;\n    }\n}","concrete-handler-3-finalbillinghandler#Concrete Handler 3: FinalBillingHandler":"/**\n * The final handler in the chain. It determines the final status\n * and saves the processed bill to the database.\n */\npublic class FinalBillingHandler implements BillingHandler {\n    private BillingHandler next; // Will be null, as this is the last handler\n    private final BillingDAO billingDAO;\n    public FinalBillingHandler() {\n        this.billingDAO = new BillingDAO();\n    }\n    @Override\n    public void setNext(BillingHandler next) {\n        this.next = next; // Usually null for final handler\n    }\n    @Override\n    public boolean processBill(BillProcessingRequest request) {\n        MedicalBill bill = request.getBill();\n        System.out.println(\"FinalBillingHandler: Finalizing and saving bill for patient \" +\n                          bill.getPatientId());\n        // Calculate remaining balance after insurance\n        double remainingBalance = bill.getRemainingBalance();\n        bill.setFinalAmount(remainingBalance);\n        // Determine final status based on remaining balance\n        if (remainingBalance <= 0) {\n            bill.setStatus(\"Closed - Fully Paid\");\n            bill.addLog(\"Bill is fully paid. No remaining balance.\");\n        } else {\n            bill.setStatus(\"Opened - Pending Payment\");\n            bill.addLog(String.format(\"Final balance of $%.2f due from patient.\", remainingBalance));\n        }\n        System.out.println(\"Final bill status: \" + bill.getStatus() + \". Saving to database...\");\n        // Save the final state of the bill to the database\n        int billId = billingDAO.saveBill(bill);\n        if (billId != -1) {\n            bill.setBillId(billId);\n            bill.addLog(\"Bill successfully saved to database with ID: \" + billId);\n            System.out.println(\"Successfully saved bill with ID: \" + billId);\n        } else {\n            bill.setStatus(\"Error - Failed to Save\");\n            bill.addLog(\"CRITICAL ERROR: Failed to save the processed bill to the database.\");\n            System.err.println(\"Failed to save bill.\");\n            return false; // Indicate failure\n        }\n        // This is the end of the chain\n        return true;\n    }\n}","3-uml-class-diagrams#3. UML Class Diagrams":"","30-comprehensive-diagram#3.0 Comprehensive Diagram":"(You can find the High Res images in the Github Project Repo)","31-chain-of-responsibility-structure#3.1 Chain of Responsibility Structure":"┌─────────────────────────────────────┐\n│          <<interface>>              │\n│        BillingHandler               │\n├─────────────────────────────────────┤\n│ + setNext(next: BillingHandler)     │\n│ + processBill(request): boolean     │\n└─────────────────────────────────────┘\n                    ▲\n        ┌───────────┼───────────┐\n        │           │           │\n┌───────────────┐ ┌──────────────┐ ┌──────────────────┐\n│ValidationHand.│ │InsuranceHand.│ │FinalBillingHand. │\n├───────────────┤ ├──────────────┤ ├──────────────────┤\n│- next: Handler│ │- next: Handler│ │- next: Handler   │\n├───────────────┤ ├──────────────┤ │- billingDAO: DAO │\n│+ setNext()    │ │+ setNext()   │ ├──────────────────┤\n│+ processBill()│ │+ processBill()│ │+ setNext()       │\n└───────────────┘ └──────────────┘ │+ processBill()   │\n                                    └──────────────────┘\n┌─────────────────────────────────────┐\n│     BillProcessingRequest           │\n│        (Request Object)             │\n├─────────────────────────────────────┤\n│- bill: MedicalBill                  │\n│- patient: PatientRecord             │\n├─────────────────────────────────────┤\n│+ getBill(): MedicalBill             │\n│+ getPatient(): PatientRecord        │\n└─────────────────────────────────────┘\n                    │\n                    │ contains\n                    ▼\n┌─────────────────────────────────────┐\n│          MedicalBill                │\n│        (Domain Object)              │\n├─────────────────────────────────────┤\n│- billId: int                        │\n│- patientId: String                  │\n│- serviceDescription: String         │\n│- amount: double                     │\n│- status: String                     │\n│- processingLog: StringBuilder       │\n│- appliedInsurancePlan: InsurancePlan│\n│- finalAmount: double                │\n│- amountPaid: double                 │\n│- insurancePaidAmount: double        │\n├─────────────────────────────────────┤\n│+ addLog(entry: String): void        │\n│+ applyInsurancePayment(amt): void   │\n│+ getRemainingBalance(): double      │\n│+ setStatus(status: String): void    │\n└─────────────────────────────────────┘","32-chain-setup-and-execution-flow#3.2 Chain Setup and Execution Flow":"BillingController\n        │\n        ▼\n    setupChain()\n        │\n        ├─→ ValidationHandler ─→ InsuranceHandler ─→ FinalBillingHandler\n        │                                                      │\n        └─────────────────── billProcessingChain ─────────────┘\n                                      │\n                                      ▼\n                            processBill(request)\n                                      │\n                        ┌─────────────┼─────────────┐\n                        │             │             │\n                   Validate      Process        Finalize\n                      │         Insurance          │\n                      ▼             │              ▼\n                 Continue/Stop       ▼         Save to DB\n                                Continue       Return Result","4-detailed-code-analysis#4. Detailed Code Analysis":"","41-chain-setup-and-configuration#4.1 Chain Setup and Configuration":"/**\n * Controller method that sets up the processing chain\n * This demonstrates the flexibility of the pattern - chains can be\n * configured differently based on business requirements\n */\nprivate BillingHandler setupChain() {\n    // Create handler instances\n    BillingHandler validationHandler = new ValidationHandler();\n    BillingHandler insuranceHandler = new InsuranceHandler();\n    BillingHandler finalBillingHandler = new FinalBillingHandler();\n    // Link handlers in sequence\n    validationHandler.setNext(insuranceHandler);\n    insuranceHandler.setNext(finalBillingHandler);\n    // Return the first handler in the chain\n    return validationHandler;\n}","42-request-processing-flow#4.2 Request Processing Flow":"/**\n * Main processing method that initiates the chain\n * The controller creates the request and starts the chain processing\n */\nprivate void processBill() {\n    // Collect and validate input data\n    String patientId = view.getPatientId();\n    String service = view.getService();\n    String amountStr = view.getAmount();\n    // Retrieve patient record for insurance information\n    PatientRecord patient = patientDAO.getPatientById(patientId);\n    if (patient == null) {\n        JOptionPane.showMessageDialog(view, \"Patient with ID '\" + patientId + \"' not found.\",\n                                     \"Validation Error\", JOptionPane.ERROR_MESSAGE);\n        return;\n    }\n    // Validate amount\n    double amount;\n    try {\n        amount = Double.parseDouble(amountStr);\n        if (amount <= 0) {\n            JOptionPane.showMessageDialog(view, \"Amount must be greater than 0.\",\n                                         \"Validation Error\", JOptionPane.ERROR_MESSAGE);\n            return;\n        }\n    } catch (NumberFormatException ex) {\n        JOptionPane.showMessageDialog(view, \"Invalid amount. Please enter a valid number.\",\n                                     \"Input Error\", JOptionPane.ERROR_MESSAGE);\n        return;\n    }\n    // Create bill and request objects\n    MedicalBill bill = new MedicalBill(patientId, service, amount);\n    BillProcessingRequest request = new BillProcessingRequest(bill, patient);\n    // Start the chain processing\n    try {\n        boolean success = billProcessingChain.processBill(request);\n        if (success) {\n            // Calculate and set insurance payment information\n            if (bill.getAmount() > bill.getFinalAmount()) {\n                double insurancePayment = bill.getAmount() - bill.getFinalAmount();\n                bill.setInsurancePaidAmount(insurancePayment);\n            }\n            // Show success message with detailed information\n            showBillProcessingResults(bill);\n        } else {\n            JOptionPane.showMessageDialog(view, \"Bill processing failed: \" + bill.getStatus(),\n                                         \"Processing Error\", JOptionPane.ERROR_MESSAGE);\n        }\n    } catch (Exception e) {\n        JOptionPane.showMessageDialog(view, \"An error occurred during bill processing: \" + e.getMessage(),\n                                     \"System Error\", JOptionPane.ERROR_MESSAGE);\n    }\n}","43-validation-logic-implementation#4.3 Validation Logic Implementation":"/**\n * ValidationHandler implements comprehensive bill validation\n * This handler can stop the chain if critical validation fails\n */\n@Override\npublic boolean processBill(BillProcessingRequest request) {\n    MedicalBill bill = request.getBill();\n    System.out.println(\"ValidationHandler: Checking bill for patient \" + bill.getPatientId());\n    // Rule 1: Amount validation\n    if (bill.getAmount() <= 0) {\n        bill.setStatus(\"Rejected: Invalid Amount\");\n        bill.addLog(\"Validation Failed: Bill amount must be positive.\");\n        System.out.println(\"Validation Failed: Amount is not positive.\");\n        return false; // Stop the chain - critical error\n    }\n    // Rule 2: Patient ID validation\n    if (bill.getPatientId() == null || bill.getPatientId().trim().isEmpty()) {\n        bill.setStatus(\"Rejected: Missing Patient ID\");\n        bill.addLog(\"Validation Failed: Patient ID is required.\");\n        System.out.println(\"Validation Failed: Patient ID is missing.\");\n        return false; // Stop the chain - critical error\n    }\n    // Additional validation rules can be added here\n    // Rule 3: Service description validation\n    if (bill.getServiceDescription() == null || bill.getServiceDescription().trim().isEmpty()) {\n        bill.setStatus(\"Rejected: Missing Service Description\");\n        bill.addLog(\"Validation Failed: Service description is required.\");\n        System.out.println(\"Validation Failed: Service description is missing.\");\n        return false;\n    }\n    // All validation passed\n    bill.setStatus(\"Validated\");\n    bill.addLog(\"Bill passed initial validation.\");\n    System.out.println(\"Validation successful.\");\n    // Continue to next handler\n    if (next != null) {\n        return next.processBill(request);\n    }\n    return true; // End of chain if no next handler\n}","44-insurance-processing-logic#4.4 Insurance Processing Logic":"/**\n * InsuranceHandler calculates coverage and applies insurance payments\n * This handler continues processing regardless of insurance status\n */\n@Override\npublic boolean processBill(BillProcessingRequest request) {\n    MedicalBill bill = request.getBill();\n    PatientRecord patient = request.getPatient();\n    InsurancePlan plan = patient.getInsurancePlan();\n    System.out.println(\"InsuranceHandler: Checking patient \" + patient.getPatientId());\n    if (plan != null) {\n        // Store insurance plan reference on the bill\n        bill.setAppliedInsurancePlan(plan);\n        // Calculate coverage amount\n        double coveragePercent = plan.getCoveragePercent();\n        double amountToCover = bill.getAmount() * (coveragePercent / 100.0);\n        // Apply the insurance payment\n        bill.applyInsurancePayment(amountToCover);\n        bill.setStatus(\"Insurance Processed\");\n        bill.addLog(String.format(\"Insurance claim processed for policy %s (%.0f%%). Covered: $%.2f\",\n                plan.getPlanName(), coveragePercent, amountToCover));\n        System.out.println(\"Insurance processed for \" + plan.getPlanName());\n    } else {\n        // No insurance - log and continue\n        bill.addLog(\"No insurance on file. Skipping claim processing.\");\n        System.out.println(\"No insurance found.\");\n    }\n    // Always continue to next handler (insurance is optional)\n    if (next != null) {\n        return next.processBill(request);\n    }\n    return true;\n}","45-final-processing-and-persistence#4.5 Final Processing and Persistence":"/**\n * FinalBillingHandler determines final amounts and persists to database\n * This is the terminal handler that completes the processing workflow\n */\n@Override\npublic boolean processBill(BillProcessingRequest request) {\n    MedicalBill bill = request.getBill();\n    System.out.println(\"FinalBillingHandler: Finalizing and saving bill for patient \" +\n                      bill.getPatientId());\n    // Calculate what the patient owes after insurance\n    double remainingBalance = bill.getRemainingBalance();\n    bill.setFinalAmount(remainingBalance);\n    // Set final status based on remaining balance\n    if (remainingBalance <= 0) {\n        bill.setStatus(\"Closed - Fully Paid\");\n        bill.addLog(\"Bill is fully paid. No remaining balance.\");\n    } else {\n        bill.setStatus(\"Opened - Pending Payment\");\n        bill.addLog(String.format(\"Final balance of $%.2f due from patient.\", remainingBalance));\n    }\n    System.out.println(\"Final bill status: \" + bill.getStatus() + \". Saving to database...\");\n    // Persist to database\n    int billId = billingDAO.saveBill(bill);\n    if (billId != -1) {\n        bill.setBillId(billId);\n        bill.addLog(\"Bill successfully saved to database with ID: \" + billId);\n        System.out.println(\"Successfully saved bill with ID: \" + billId);\n        return true; // Success\n    } else {\n        bill.setStatus(\"Error - Failed to Save\");\n        bill.addLog(\"CRITICAL ERROR: Failed to save the processed bill to the database.\");\n        System.err.println(\"Failed to save bill.\");\n        return false; // Indicate failure\n    }\n}","5-multi-step-processing-workflow#5. Multi-Step Processing Workflow":"","51-complete-processing-sequence#5.1 Complete Processing Sequence":"/**\n * Example of a complete bill processing workflow\n * This demonstrates how the chain handles a typical billing scenario\n */\npublic void demonstrateCompleteWorkflow() {\n    // Step 1: Create initial bill\n    MedicalBill bill = new MedicalBill(\"P001\", \"Annual Checkup\", 200.00);\n    // Step 2: Retrieve patient with insurance information\n    PatientRecord patient = patientDAO.getPatientById(\"P001\");\n    // Assume patient has 80% coverage insurance plan\n    // Step 3: Create processing request\n    BillProcessingRequest request = new BillProcessingRequest(bill, patient);\n    // Step 4: Execute chain processing\n    boolean success = billProcessingChain.processBill(request);\n    // Expected results after processing:\n    // - bill.getAmount() = 200.00 (original amount)\n    // - bill.getInsurancePaidAmount() = 160.00 (80% coverage)\n    // - bill.getFinalAmount() = 40.00 (patient responsibility)\n    // - bill.getStatus() = \"Opened - Pending Payment\"\n    // - bill.getBillId() > 0 (assigned by database)\n}","52-error-handling-and-chain-termination#5.2 Error Handling and Chain Termination":"/**\n * Example showing how validation errors terminate the chain\n */\npublic void demonstrateValidationFailure() {\n    // Create invalid bill (negative amount)\n    MedicalBill invalidBill = new MedicalBill(\"P001\", \"Invalid Service\", -50.00);\n    PatientRecord patient = patientDAO.getPatientById(\"P001\");\n    BillProcessingRequest request = new BillProcessingRequest(invalidBill, patient);\n    // Processing will stop at ValidationHandler\n    boolean success = billProcessingChain.processBill(request);\n    // Expected results:\n    // - success = false\n    // - bill.getStatus() = \"Rejected: Invalid Amount\"\n    // - InsuranceHandler and FinalBillingHandler never executed\n    // - No database persistence occurs\n}","53-insurance-coverage-scenarios#5.3 Insurance Coverage Scenarios":"/**\n * Different insurance scenarios handled by the chain\n */\npublic void demonstrateInsuranceScenarios() {\n    // Scenario 1: Patient with 100% coverage\n    MedicalBill bill1 = new MedicalBill(\"P001\", \"Covered Service\", 100.00);\n    // After processing: finalAmount = 0.00, status = \"Closed - Fully Paid\"\n    // Scenario 2: Patient with no insurance\n    MedicalBill bill2 = new MedicalBill(\"P002\", \"Self-Pay Service\", 150.00);\n    // After processing: finalAmount = 150.00, status = \"Opened - Pending Payment\"\n    // Scenario 3: Patient with partial coverage\n    MedicalBill bill3 = new MedicalBill(\"P003\", \"Partial Coverage\", 300.00);\n    // 70% coverage: finalAmount = 90.00, status = \"Opened - Pending Payment\"\n}","6-usage-scenarios#6. Usage Scenarios":"","61-scenario-1-standard-insurance-claim-processing#6.1 Scenario 1: Standard Insurance Claim Processing":"// Setup: Patient with 80% insurance coverage\nPatientRecord patient = new PatientRecord(\"P001\", \"John Doe\");\nInsurancePlan plan = new InsurancePlan(1, \"Blue Cross\", 80.0);\npatient.setInsurancePlan(plan);\n// Create bill for $500 medical service\nMedicalBill bill = new MedicalBill(\"P001\", \"MRI Scan\", 500.00);\nBillProcessingRequest request = new BillProcessingRequest(bill, patient);\n// Process through chain\nboolean success = chain.processBill(request);\n// Expected results:\n// - Validation: Passed\n// - Insurance: $400.00 covered (80% of $500)\n// - Final: $100.00 patient responsibility\n// - Status: \"Opened - Pending Payment\"\n// - Database: Bill saved with assigned ID","62-scenario-2-validation-failure#6.2 Scenario 2: Validation Failure":"// Create bill with invalid data\nMedicalBill invalidBill = new MedicalBill(\"\", \"Service\", -100.00);\nPatientRecord patient = new PatientRecord(\"P002\", \"Jane Smith\");\nBillProcessingRequest request = new BillProcessingRequest(invalidBill, patient);\n// Process through chain\nboolean success = chain.processBill(request);\n// Expected results:\n// - success = false\n// - Status: \"Rejected: Missing Patient ID\" (first validation failure)\n// - Chain terminated at ValidationHandler\n// - No insurance processing\n// - No database persistence","63-scenario-3-no-insurance-coverage#6.3 Scenario 3: No Insurance Coverage":"// Setup: Patient without insurance\nPatientRecord patient = new PatientRecord(\"P003\", \"Bob Wilson\");\n// No insurance plan set\n// Create bill\nMedicalBill bill = new MedicalBill(\"P003\", \"Consultation\", 150.00);\nBillProcessingRequest request = new BillProcessingRequest(bill, patient);\n// Process through chain\nboolean success = chain.processBill(request);\n// Expected results:\n// - Validation: Passed\n// - Insurance: Skipped (no coverage)\n// - Final: $150.00 patient responsibility\n// - Status: \"Opened - Pending Payment\"\n// - Database: Bill saved successfully","64-scenario-4-full-insurance-coverage#6.4 Scenario 4: Full Insurance Coverage":"// Setup: Patient with 100% coverage\nPatientRecord patient = new PatientRecord(\"P004\", \"Alice Brown\");\nInsurancePlan fullCoverage = new InsurancePlan(2, \"Premium Plan\", 100.0);\npatient.setInsurancePlan(fullCoverage);\n// Create bill\nMedicalBill bill = new MedicalBill(\"P004\", \"Emergency Room Visit\", 800.00);\nBillProcessingRequest request = new BillProcessingRequest(bill, patient);\n// Process through chain\nboolean success = chain.processBill(request);\n// Expected results:\n// - Validation: Passed\n// - Insurance: $800.00 covered (100% of $800)\n// - Final: $0.00 patient responsibility\n// - Status: \"Closed - Fully Paid\"\n// - Database: Bill saved as fully paid","7-benefits--trade-offs#7. Benefits & Trade-offs":"","71-chain-of-responsibility-benefits#7.1 Chain of Responsibility Benefits":"Flexibility and Extensibility\nEasy to add new processing steps without modifying existing handlers\nCan reorder handlers to change processing sequence\nDifferent chains can be configured for different bill types\nHandlers can be reused in multiple processing workflows\nSeparation of Concerns\nEach handler focuses on a single responsibility\nValidation logic separated from insurance processing\nDatabase persistence isolated in final handler\nClear audit trail through processing log\nLoose Coupling\nHandlers don't need to know about other handlers in the chain\nRequest object encapsulates all necessary data\nEasy to test individual handlers in isolation\nReduced dependencies between processing components\nDynamic Processing Control\nHandlers can terminate the chain based on conditions\nOptional processing steps (like insurance) can be skipped gracefully\nError handling contained within appropriate handlers\nProcessing can branch based on business rules","72-healthcare-domain-specific-benefits#7.2 Healthcare Domain Specific Benefits":"Compliance and Audit Trail\nComplete processing log maintained throughout the chain\nEach step documented for regulatory compliance\nClear responsibility assignment for each processing stage\nTraceable decision-making process\nBusiness Rule Management\nInsurance rules centralized in InsuranceHandler\nValidation rules can be easily modified or extended\nDifferent processing rules for different insurance types\nConfigurable coverage calculations\nError Recovery and Handling\nFailed validation prevents incorrect billing\nInsurance processing failures don't stop the entire workflow\nDatabase errors properly handled and logged\nClear error messages for each failure type","73-trade-offs-and-considerations#7.3 Trade-offs and Considerations":"Processing Overhead\nAdditional object creation for request wrappers\nChain traversal adds method call overhead\nLogging operations increase processing time\nMemory usage for maintaining processing logs\nDebugging Complexity\nMultiple handlers make debugging more complex\nChain execution flow can be hard to follow\nError sources may be unclear across multiple handlers\nTesting requires careful setup of handler chains\nConfiguration Management\nChain setup must be done correctly for proper operation\nHandler order is critical for correct processing\nDifferent environments may require different chains\nConfiguration errors can lead to incorrect processing\nPerformance Considerations\nChain processing is sequential, not parallel\nDatabase operations in final handler can become bottleneck\nLarge processing logs consume memory\nException handling overhead across multiple handlers","8-testing--validation#8. Testing & Validation":"","81-unit-testing-individual-handlers#8.1 Unit Testing Individual Handlers":"@Test\npublic void testValidationHandlerSuccess() {\n    // Arrange\n    ValidationHandler handler = new ValidationHandler();\n    MedicalBill validBill = new MedicalBill(\"P001\", \"Service\", 100.00);\n    PatientRecord patient = new PatientRecord(\"P001\", \"Test Patient\");\n    BillProcessingRequest request = new BillProcessingRequest(validBill, patient);\n    // Act\n    boolean result = handler.processBill(request);\n    // Assert\n    assertTrue(result);\n    assertEquals(\"Validated\", validBill.getStatus());\n    assertTrue(validBill.getProcessingLog().contains(\"Bill passed initial validation\"));\n}\n@Test\npublic void testValidationHandlerFailure() {\n    // Arrange\n    ValidationHandler handler = new ValidationHandler();\n    MedicalBill invalidBill = new MedicalBill(\"P001\", \"Service\", -50.00);\n    PatientRecord patient = new PatientRecord(\"P001\", \"Test Patient\");\n    BillProcessingRequest request = new BillProcessingRequest(invalidBill, patient);\n    // Act\n    boolean result = handler.processBill(request);\n    // Assert\n    assertFalse(result);\n    assertEquals(\"Rejected: Invalid Amount\", invalidBill.getStatus());\n    assertTrue(invalidBill.getProcessingLog().contains(\"Bill amount must be positive\"));\n}\n@Test\npublic void testInsuranceHandlerWithCoverage() {\n    // Arrange\n    InsuranceHandler handler = new InsuranceHandler();\n    MedicalBill bill = new MedicalBill(\"P001\", \"Service\", 200.00);\n    PatientRecord patient = new PatientRecord(\"P001\", \"Test Patient\");\n    InsurancePlan plan = new InsurancePlan(1, \"Test Plan\", 80.0);\n    patient.setInsurancePlan(plan);\n    BillProcessingRequest request = new BillProcessingRequest(bill, patient);\n    // Act\n    boolean result = handler.processBill(request);\n    // Assert\n    assertTrue(result);\n    assertEquals(\"Insurance Processed\", bill.getStatus());\n    assertEquals(160.00, bill.getInsurancePaidAmount(), 0.01);\n    assertEquals(plan, bill.getAppliedInsurancePlan());\n}\n@Test\npublic void testInsuranceHandlerWithoutCoverage() {\n    // Arrange\n    InsuranceHandler handler = new InsuranceHandler();\n    MedicalBill bill = new MedicalBill(\"P001\", \"Service\", 200.00);\n    PatientRecord patient = new PatientRecord(\"P001\", \"Test Patient\");\n    // No insurance plan set\n    BillProcessingRequest request = new BillProcessingRequest(bill, patient);\n    // Act\n    boolean result = handler.processBill(request);\n    // Assert\n    assertTrue(result);\n    assertEquals(0.00, bill.getInsurancePaidAmount(), 0.01);\n    assertNull(bill.getAppliedInsurancePlan());\n    assertTrue(bill.getProcessingLog().contains(\"No insurance on file\"));\n}","82-integration-testing-chain-processing#8.2 Integration Testing Chain Processing":"@Test\npublic void testCompleteChainProcessing() {\n    // Arrange\n    BillingHandler chain = setupTestChain();\n    MedicalBill bill = new MedicalBill(\"P001\", \"Test Service\", 300.00);\n    PatientRecord patient = new PatientRecord(\"P001\", \"Test Patient\");\n    InsurancePlan plan = new InsurancePlan(1, \"Test Plan\", 70.0);\n    patient.setInsurancePlan(plan);\n    BillProcessingRequest request = new BillProcessingRequest(bill, patient);\n    // Act\n    boolean result = chain.processBill(request);\n    // Assert\n    assertTrue(result);\n    assertEquals(\"Opened - Pending Payment\", bill.getStatus());\n    assertEquals(210.00, bill.getInsurancePaidAmount(), 0.01); // 70% of 300\n    assertEquals(90.00, bill.getFinalAmount(), 0.01); // 30% patient responsibility\n    assertTrue(bill.getBillId() > 0); // Assigned by database\n}\n@Test\npublic void testChainTerminationOnValidationFailure() {\n    // Arrange\n    BillingHandler chain = setupTestChain();\n    MedicalBill invalidBill = new MedicalBill(\"\", \"Service\", 100.00); // Invalid patient ID\n    PatientRecord patient = new PatientRecord(\"P001\", \"Test Patient\");\n    BillProcessingRequest request = new BillProcessingRequest(invalidBill, patient);\n    // Act\n    boolean result = chain.processBill(request);\n    // Assert\n    assertFalse(result);\n    assertEquals(\"Rejected: Missing Patient ID\", invalidBill.getStatus());\n    assertEquals(0.00, invalidBill.getInsurancePaidAmount(), 0.01); // Insurance not processed\n    assertEquals(0, invalidBill.getBillId()); // Not saved to database\n}","83-performance-testing#8.3 Performance Testing":"@Test\npublic void testChainPerformanceWithLargeBatch() {\n    // Arrange\n    BillingHandler chain = setupTestChain();\n    List<BillProcessingRequest> requests = createTestBatch(1000);\n    // Act\n    long startTime = System.currentTimeMillis();\n    int successCount = 0;\n    for (BillProcessingRequest request : requests) {\n        if (chain.processBill(request)) {\n            successCount++;\n        }\n    }\n    long endTime = System.currentTimeMillis();\n    // Assert\n    assertEquals(1000, successCount);\n    assertTrue(\"Processing should complete within 5 seconds\",\n               (endTime - startTime) < 5000);\n}","84-error-handling-testing#8.4 Error Handling Testing":"@Test\npublic void testDatabaseFailureHandling() {\n    // Arrange - Mock DAO to simulate database failure\n    BillingHandler chain = setupChainWithMockDAO();\n    MedicalBill bill = new MedicalBill(\"P001\", \"Service\", 100.00);\n    PatientRecord patient = new PatientRecord(\"P001\", \"Test Patient\");\n    BillProcessingRequest request = new BillProcessingRequest(bill, patient);\n    // Configure mock to fail\n    when(mockBillingDAO.saveBill(any())).thenReturn(-1);\n    // Act\n    boolean result = chain.processBill(request);\n    // Assert\n    assertFalse(result);\n    assertEquals(\"Error - Failed to Save\", bill.getStatus());\n    assertTrue(bill.getProcessingLog().contains(\"CRITICAL ERROR: Failed to save\"));\n}","conclusion#Conclusion":"The Chain of Responsibility pattern implementation in the billing and insurance processing system demonstrates a sophisticated approach to handling complex, multi-step workflows in healthcare software. The pattern successfully addresses the core challenges of medical billing while providing a flexible, maintainable, and extensible architecture.","key-achievements#Key Achievements":"Workflow Management: Successfully implements a complex billing workflow with validation, insurance processing, and persistence\nFlexibility: Easy to add new processing steps or modify existing ones without affecting other components\nError Handling: Robust error handling with appropriate chain termination and detailed logging\nInsurance Integration: Seamless integration of insurance claim processing with configurable coverage rules\nAudit Trail: Complete processing log maintained throughout the entire workflow\nDatabase Integration: Clean separation between business logic and data persistence","real-world-healthcare-impact#Real-World Healthcare Impact":"The Chain of Responsibility pattern proves particularly valuable in healthcare billing contexts where:\nRegulatory Compliance requires detailed audit trails and processing documentation\nInsurance Complexity demands flexible coverage calculation and claim processing\nError Prevention is critical for accurate billing and patient satisfaction\nWorkflow Flexibility allows adaptation to different healthcare provider requirements\nIntegration Requirements need clean interfaces between billing, insurance, and accounting systems","pattern-benefits-realized#Pattern Benefits Realized":"The implementation successfully demonstrates how the Chain of Responsibility pattern can:\nDecouple complex processing steps while maintaining workflow integrity\nCentralize business rules within appropriate handler responsibilities\nEnable dynamic processing control with early termination capabilities\nSupport extensibility for evolving healthcare regulations and requirements\nProvide clear separation between validation, processing, and persistence concerns\nThe billing system's chain-based architecture provides a solid foundation for handling the complexities of healthcare financial processing while maintaining the flexibility needed for future enhancements and regulatory changes.Document Status: Part C CompleteNext: Part D - Managing Medical Staff Roles and Permissions (Decorator Pattern)"}},"/":{"title":"GlobeMed Healthcare Management System","data":{"":"Welcome to the comprehensive documentation for the GlobeMed Healthcare Management System - a sophisticated Java-based desktop application that demonstrates advanced software engineering principles through practical implementation of design patterns.","-purpose#🎯 Purpose":"This system serves as both a functional healthcare management solution and an educational resource for understanding enterprise-level software architecture with targeted pattern implementations.","️-architecture-overview#🏗️ Architecture Overview":"The GlobeMed system is built around 6 core design patterns, each addressing specific healthcare domain challenges:","-patient-record-management#📋 Patient Record Management":"Patterns: Memento & Prototype\nFeatures: State restoration, undo functionality, efficient record creation","-appointment-scheduling#📅 Appointment Scheduling":"Pattern: Mediator\nFeatures: Complex interaction mediation between patients, doctors, and scheduling systems","-billing--insurance-claims#💰 Billing & Insurance Claims":"Pattern: Chain of Responsibility\nFeatures: Flexible workflow processing, validation chains, insurance claim handling","-staff-roles--permissions#👥 Staff Roles & Permissions":"Pattern: Decorator\nFeatures: Dynamic role-based access control, fine-grained permissions","-medical-reports-generation#📊 Medical Reports Generation":"Pattern: Visitor\nFeatures: Extensible report generation, multi-format output, data aggregation","-security-considerations#🔒 Security Considerations":"Patterns: Decorator & DAO\nFeatures: Comprehensive data protection, secure access patterns","-technology-stack#🚀 Technology Stack":"Component\tTechnology\tLanguage\tJava\tJDK Version\tJDK 21\tDatabase\tMySQL 9.3.0\tUI Framework\tJava SE Swing\tPDF Generation\tiTextPDF, pdfBox\tBuild Tool\tApache Maven","-documentation-structure#📖 Documentation Structure":"This documentation is organized into focused sections, each covering a specific design pattern implementation with:\nProblem Statement: Real healthcare domain challenges\nPattern Implementation: Detailed code analysis and UML diagrams\nUsage Scenarios: Practical application examples\nTesting & Validation: Comprehensive test coverage\nBenefits & Trade-offs: Pattern-specific advantages and considerations","-quick-links#🔗 Quick Links":"System Overview - Complete foundation document\nGitHub Repository - Source code\nLive Demo - GitBook publication\nBuilt with ❤️ by Ishara Lakshitha for academic and educational purposes."}},"/patient-records":{"title":"Patient Record Management","data":{"":"Document: Part A AnalysisPatterns: Memento Pattern & Prototype PatternModule: Patient Record ManagementAuthor: Ishara Lakshitha","table-of-contents#Table of Contents":"","1-overview--problem-statement#1. Overview & Problem Statement":"","healthcare-domain-problems-addressed#Healthcare Domain Problems Addressed":"Problem 1: State Management with Undo Capability\nHealthcare professionals need to modify patient records frequently\nMistakes in patient data can have serious consequences\nNeed ability to undo changes without losing data integrity\nMust maintain complete audit trail of modifications\nProblem 2: Efficient Patient Record Creation\nCreating new patient records from scratch is time-consuming\nMany patients share similar baseline information\nNeed template-based record creation for efficiency\nMust ensure data independence between records","solution-approach#Solution Approach":"The implementation combines two creational/behavioral patterns:\nMemento Pattern: Captures and restores patient record state without violating encapsulation\nPrototype Pattern: Enables efficient patient record creation through cloning","2-design-patterns-implementation#2. Design Patterns Implementation":"","21-memento-pattern-implementation#2.1 Memento Pattern Implementation":"","pattern-participants#Pattern Participants":"// Originator\npublic class PatientRecord implements Cloneable, Visitable {\n    // State to be saved/restored\n    private String name;\n    private List<String> medicalHistory;\n    private List<String> treatmentPlans;\n    // Memento creation\n    public PatientRecordMemento save() {\n        return new PatientRecordMemento(\n            this.name,\n            new ArrayList<>(this.medicalHistory),\n            new ArrayList<>(this.treatmentPlans)\n        );\n    }\n    // State restoration\n    public void restore(PatientRecordMemento memento) {\n        this.name = memento.getName();\n        this.medicalHistory = memento.getMedicalHistory();\n        this.treatmentPlans = memento.getTreatmentPlans();\n    }\n}\n// Memento\npublic final class PatientRecordMemento {\n    private final String name;\n    private final List<String> medicalHistory;\n    private final List<String> treatmentPlans;\n    public PatientRecordMemento(String name, List<String> medicalHistory,\n                               List<String> treatmentPlans) {\n        this.name = name;\n        this.medicalHistory = new ArrayList<>(medicalHistory); // Deep copy\n        this.treatmentPlans = new ArrayList<>(treatmentPlans); // Deep copy\n    }\n    // Package-private getters for encapsulation\n    String getName() { return name; }\n    List<String> getMedicalHistory() { return new ArrayList<>(medicalHistory); }\n    List<String> getTreatmentPlans() { return new ArrayList<>(treatmentPlans); }\n}\n// Caretaker\npublic class RecordHistory {\n    private final Stack<PatientRecordMemento> history = new Stack<>();\n    private final PatientRecord patientRecord;\n    public void save() {\n        System.out.println(\"Saving state...\");\n        history.push(patientRecord.save());\n    }\n    public void undo() {\n        if (history.isEmpty()) {\n            System.out.println(\"Cannot undo. No history available.\");\n            return;\n        }\n        PatientRecordMemento lastState = history.pop();\n        System.out.println(\"Restoring to previous state...\");\n        patientRecord.restore(lastState);\n    }\n}","22-prototype-pattern-implementation#2.2 Prototype Pattern Implementation":"","deep-cloning-implementation#Deep Cloning Implementation":"public class PatientRecord implements Cloneable, Visitable {\n    @Override\n    public PatientRecord clone() {\n        try {\n            PatientRecord clonedRecord = (PatientRecord) super.clone();\n            // Perform deep copy of mutable fields\n            clonedRecord.medicalHistory = new ArrayList<>(this.medicalHistory);\n            clonedRecord.treatmentPlans = new ArrayList<>(this.treatmentPlans);\n            return clonedRecord;\n        } catch (CloneNotSupportedException e) {\n            throw new AssertionError(); // Should not happen since we implement Cloneable\n        }\n    }\n}","3-uml-class-diagrams#3. UML Class Diagrams":"","30-comprehensive-diagram#3.0 Comprehensive Diagram":"(You can find the High Res images in the Github Project Repo)","31-memento-pattern-structure#3.1 Memento Pattern Structure":"┌─────────────────────────────────────┐\n│            PatientRecord            │\n│            (Originator)             │\n├─────────────────────────────────────┤\n│ - name: String                      │\n│ - medicalHistory: List<String>      │\n│ - treatmentPlans: List<String>      │\n├─────────────────────────────────────┤\n│ + save(): PatientRecordMemento      │\n│ + restore(memento): void            │\n│ + setName(name): void               │\n│ + addMedicalHistory(history): void  │\n│ + addTreatmentPlan(plan): void      │\n└─────────────────────────────────────┘\n                    │\n                    │ creates\n                    ▼\n┌─────────────────────────────────────┐\n│        PatientRecordMemento         │\n│            (Memento)                │\n├─────────────────────────────────────┤\n│ - name: String                      │\n│ - medicalHistory: List<String>      │\n│ - treatmentPlans: List<String>      │\n├─────────────────────────────────────┤\n│ + getName(): String                 │\n│ + getMedicalHistory(): List<String> │\n│ + getTreatmentPlans(): List<String> │\n└─────────────────────────────────────┘\n                    ▲\n                    │ stores\n                    │\n┌─────────────────────────────────────┐\n│          RecordHistory              │\n│          (Caretaker)                │\n├─────────────────────────────────────┤\n│ - history: Stack<PatientRecordMem.> │\n│ - patientRecord: PatientRecord      │\n├─────────────────────────────────────┤\n│ + save(): void                      │\n│ + undo(): void                      │\n└─────────────────────────────────────┘","32-prototype-pattern-structure#3.2 Prototype Pattern Structure":"┌─────────────────────────────────────┐\n│         <<interface>>               │\n│           Cloneable                 │\n└─────────────────────────────────────┘\n                    ▲\n                    │\n                    │ implements\n┌─────────────────────────────────────┐\n│         PatientRecord               │\n│         (Prototype)                 │\n├─────────────────────────────────────┤\n│ - patientId: String                 │\n│ - name: String                      │\n│ - medicalHistory: List<String>      │\n│ - treatmentPlans: List<String>      │\n│ - insurancePlan: InsurancePlan      │\n├─────────────────────────────────────┤\n│ + clone(): PatientRecord            │\n│ + PatientRecord(id, name)           │\n└─────────────────────────────────────┘","4-detailed-code-analysis#4. Detailed Code Analysis":"","41-memento-pattern-deep-dive#4.1 Memento Pattern Deep Dive":"","state-capture-mechanism#State Capture Mechanism":"/**\n * Creates a snapshot of current patient record state\n * Key Design Decisions:\n * 1. Deep copying of mutable collections prevents external modification\n * 2. Immutable fields (patientId) are not included in memento\n * 3. Only essential state for undo functionality is captured\n */\npublic PatientRecordMemento save() {\n    return new PatientRecordMemento(\n        this.name,                              // Simple field copy\n        new ArrayList<>(this.medicalHistory),   // Deep copy for safety\n        new ArrayList<>(this.treatmentPlans)    // Deep copy for safety\n    );\n}","state-restoration-mechanism#State Restoration Mechanism":"/**\n * Restores patient record from memento state\n * Key Design Decisions:\n * 1. Memento provides defensive copies to prevent external modification\n * 2. Only mutable state is restored (patientId remains unchanged)\n * 3. Direct assignment ensures complete state replacement\n */\npublic void restore(PatientRecordMemento memento) {\n    this.name = memento.getName();                    // Direct assignment\n    this.medicalHistory = memento.getMedicalHistory(); // Gets defensive copy\n    this.treatmentPlans = memento.getTreatmentPlans(); // Gets defensive copy\n}","encapsulation-protection#Encapsulation Protection":"public final class PatientRecordMemento {\n    // Package-private access ensures only PatientRecord can access state\n    String getName() { return name; }\n    // Always return defensive copies to prevent external modification\n    List<String> getMedicalHistory() {\n        return new ArrayList<>(medicalHistory);\n    }\n    List<String> getTreatmentPlans() {\n        return new ArrayList<>(treatmentPlans);\n    }\n}","42-prototype-pattern-deep-dive#4.2 Prototype Pattern Deep Dive":"","deep-cloning-implementation-1#Deep Cloning Implementation":"@Override\npublic PatientRecord clone() {\n    try {\n        // Step 1: Perform shallow clone using Object.clone()\n        PatientRecord clonedRecord = (PatientRecord) super.clone();\n        // Step 2: Deep copy mutable reference fields\n        clonedRecord.medicalHistory = new ArrayList<>(this.medicalHistory);\n        clonedRecord.treatmentPlans = new ArrayList<>(this.treatmentPlans);\n        // Note: Immutable fields (String patientId, String name) are safely shared\n        // Note: InsurancePlan reference sharing is acceptable for this use case\n        return clonedRecord;\n    } catch (CloneNotSupportedException e) {\n        throw new AssertionError(); // Should never happen\n    }\n}","constructor-vs-clone-performance-analysis#Constructor vs Clone Performance Analysis":"// Traditional constructor approach\nPatientRecord newPatient = new PatientRecord(\"P002\", \"John Doe\");\nnewPatient.setMedicalHistory(existingHistory);\nnewPatient.setTreatmentPlans(existingPlans);\nnewPatient.setInsurancePlan(existingPlan);\n// Prototype pattern approach\nPatientRecord templatePatient = /* existing patient with baseline data */;\nPatientRecord newPatient = templatePatient.clone();\nnewPatient.setPatientId(\"P002\");  // Only change what's different\nnewPatient.setName(\"John Doe\");","5-pattern-integration#5. Pattern Integration":"","51-controller-integration#5.1 Controller Integration":"public class PatientController {\n    private PatientRecord currentPatient;\n    private RecordHistory recordHistory;  // Memento caretaker\n    private void searchPatient() {\n        currentPatient = dao.getPatientById(patientId);\n        if (currentPatient != null) {\n            // Initialize memento system for undo functionality\n            recordHistory = new RecordHistory(currentPatient);\n            displayPatientData();\n        }\n    }\n    private void editPatient() {\n        // Save current state before allowing edits\n        recordHistory.save();\n        view.setFieldsEditable(true);\n    }\n    private void undoChanges() {\n        if (recordHistory != null) {\n            recordHistory.undo();        // Restore from memento\n            displayPatientData();        // Update UI with restored state\n        }\n    }\n}","52-workflow-integration#5.2 Workflow Integration":"User Workflow:\n1. Search Patient → Load existing record → Create RecordHistory\n2. Edit Patient → Save current state to memento → Enable editing\n3. Make Changes → Modify patient record state\n4. Undo (Optional) → Restore from memento → Update UI\n5. Save Changes → Persist to database → Clear undo history","6-usage-scenarios#6. Usage Scenarios":"","61-scenario-1-medical-record-editing-with-undo#6.1 Scenario 1: Medical Record Editing with Undo":"// 1. User loads patient record\nPatientRecord patient = dao.getPatientById(\"P001\");\nRecordHistory history = new RecordHistory(patient);\n// 2. User starts editing - save current state\nhistory.save();\npatient.setName(\"Updated Name\");\npatient.addMedicalHistory(\"New diagnosis: Hypertension\");\n// 3. User realizes mistake and wants to undo\nhistory.undo();  // Restores to state before editing\n// 4. Patient record is back to original state\nassert patient.getName().equals(\"Original Name\");","62-scenario-2-creating-patient-templates#6.2 Scenario 2: Creating Patient Templates":"// 1. Create a baseline patient template\nPatientRecord template = new PatientRecord(\"TEMPLATE\", \"Template Patient\");\ntemplate.addMedicalHistory(\"Standard health screening completed\");\ntemplate.addTreatmentPlan(\"Annual checkup recommended\");\ntemplate.setInsurancePlan(standardInsurancePlan);\n// 2. Use template to create new patients efficiently\nPatientRecord newPatient1 = template.clone();\nnewPatient1.setPatientId(\"P003\");\nnewPatient1.setName(\"Alice Johnson\");\nPatientRecord newPatient2 = template.clone();\nnewPatient2.setPatientId(\"P004\");\nnewPatient2.setName(\"Bob Smith\");","63-scenario-3-complex-editing-session#6.3 Scenario 3: Complex Editing Session":"RecordHistory history = new RecordHistory(patient);\n// Multiple edit points with saves\nhistory.save();  // Save point 1\npatient.addMedicalHistory(\"Initial consultation\");\nhistory.save();  // Save point 2\npatient.addTreatmentPlan(\"Medication prescribed\");\nhistory.save();  // Save point 3\npatient.addMedicalHistory(\"Follow-up scheduled\");\n// User wants to undo back to save point 2\nhistory.undo();  // Removes follow-up\nhistory.undo();  // Removes treatment plan\n// Now at save point 1 with only initial consultation","7-benefits--trade-offs#7. Benefits & Trade-offs":"","71-memento-pattern-benefits#7.1 Memento Pattern Benefits":"Encapsulation Preservation\nInternal state never exposed to external classes\nPackage-private access ensures controlled state access\nMemento is opaque to caretaker (RecordHistory)\nUndo/Redo Capability\nClean undo functionality without complex state tracking\nMultiple save points supported through stack structure\nAtomic state restoration guarantees consistency\nFlexibility\nEasy to extend to support redo functionality\nCan implement selective state restoration\nSupports branching undo scenarios","72-prototype-pattern-benefits#7.2 Prototype Pattern Benefits":"Performance Optimization\nAvoids expensive object initialization\nReduces constructor complexity for template objects\nEfficient for objects with complex default state\nFlexibility in Object Creation\nRuntime determination of object types to create\nEasy template management and versioning\nSupports object creation without knowing concrete classes","73-trade-offs-and-considerations#7.3 Trade-offs and Considerations":"Memory Usage\nMemento pattern: Each save point consumes memory\nDeep copying in both patterns increases memory footprint\nStack growth in RecordHistory needs monitoring\nComplexity\nAdditional classes and relationships to maintain\nDeep vs shallow copying decisions need careful consideration\nSynchronization concerns in multi-threaded environments\nPerformance\nClone operation has O(n) complexity for collections\nMemento creation and restoration overhead\nStack operations add computational cost","8-testing--validation#8. Testing & Validation":"","81-memento-pattern-test-cases#8.1 Memento Pattern Test Cases":"@Test\npublic void testMementoBasicSaveRestore() {\n    PatientRecord patient = new PatientRecord(\"P001\", \"John Doe\");\n    RecordHistory history = new RecordHistory(patient);\n    // Save initial state\n    history.save();\n    // Modify state\n    patient.setName(\"Jane Doe\");\n    patient.addMedicalHistory(\"Diagnosis added\");\n    // Verify changes\n    assertEquals(\"Jane Doe\", patient.getName());\n    assertEquals(1, patient.getMedicalHistoryList().size());\n    // Restore and verify\n    history.undo();\n    assertEquals(\"John Doe\", patient.getName());\n    assertEquals(0, patient.getMedicalHistoryList().size());\n}\n@Test\npublic void testMementoEncapsulation() {\n    PatientRecord patient = new PatientRecord(\"P001\", \"John Doe\");\n    PatientRecordMemento memento = patient.save();\n    // Verify memento returns defensive copies\n    List<String> history1 = memento.getMedicalHistory();\n    List<String> history2 = memento.getMedicalHistory();\n    assertNotSame(history1, history2);  // Different instances\n    assertEquals(history1, history2);    // Same content\n}","82-prototype-pattern-test-cases#8.2 Prototype Pattern Test Cases":"@Test\npublic void testPrototypeDeepCloning() {\n    PatientRecord original = new PatientRecord(\"P001\", \"John Doe\");\n    original.addMedicalHistory(\"Original history\");\n    PatientRecord clone = original.clone();\n    // Verify independence\n    clone.addMedicalHistory(\"Clone history\");\n    assertEquals(1, original.getMedicalHistoryList().size());\n    assertEquals(2, clone.getMedicalHistoryList().size());\n}\n@Test\npublic void testPrototypeSharedImmutableData() {\n    PatientRecord original = new PatientRecord(\"P001\", \"John Doe\");\n    PatientRecord clone = original.clone();\n    // Immutable strings can be safely shared\n    assertSame(original.getPatientId(), clone.getPatientId());\n    assertSame(original.getName(), clone.getName());\n}","83-integration-test-scenarios#8.3 Integration Test Scenarios":"@Test\npublic void testMementoWithPrototype() {\n    // Create template\n    PatientRecord template = new PatientRecord(\"TEMPLATE\", \"Template\");\n    template.addMedicalHistory(\"Standard screening\");\n    // Clone template\n    PatientRecord patient = template.clone();\n    patient.setPatientId(\"P001\");\n    patient.setName(\"John Doe\");\n    // Test memento on cloned object\n    RecordHistory history = new RecordHistory(patient);\n    history.save();\n    patient.addMedicalHistory(\"New diagnosis\");\n    history.undo();\n    // Should restore to post-clone state\n    assertEquals(\"John Doe\", patient.getName());\n    assertEquals(1, patient.getMedicalHistoryList().size());\n    assertEquals(\"Standard screening\", patient.getMedicalHistoryList().get(0));\n}","84-ui-integration-validation#8.4 UI Integration Validation":"User Workflow Testing\nLoad patient record → Verify RecordHistory initialization\nClick \"Edit\" → Verify memento save operation\nModify data → Verify UI updates\nClick \"Undo\" → Verify state restoration and UI refresh\nVerify database consistency after operations\nPerformance Testing\nMeasure memento creation time for records with large medical histories\nTest memory usage with multiple save points\nValidate clone operation performance with complex patient records","conclusion#Conclusion":"The implementation of Memento and Prototype patterns in the patient record management system demonstrates a sophisticated approach to state management and object creation in healthcare software. The patterns work together to provide:\nRobust Undo Functionality: Critical for healthcare data integrity\nEfficient Record Creation: Important for busy healthcare environments\nProper Encapsulation: Essential for sensitive medical data\nScalable Architecture: Supports complex healthcare workflows\nThe dual-pattern approach addresses real-world healthcare domain challenges while maintaining clean, maintainable code that follows established design principles.Document Status: Part A CompleteNext: Part B - Appointment Scheduling (Mediator Pattern)"}},"/security":{"title":"Security Considerations","data":{"":"Document: Part F AnalysisPatterns: Decorator Pattern (Authentication), DAO Pattern (Data Access Security)Module: Security Architecture and Data ProtectionAuthor: Ishara Lakshitha","table-of-contents#Table of Contents":"","1-overview--security-architecture#1. Overview & Security Architecture":"","healthcare-security-requirements#Healthcare Security Requirements":"HIPAA Compliance Considerations\nPatient data confidentiality and integrity protection\nAccess logging and audit trail requirements\nRole-based access control for medical information\nSecure authentication and authorization mechanisms\nCritical Security Domains\nAuthentication Security: User credential verification and session management\nAuthorization Security: Role-based permission enforcement\nData Access Security: Protected database operations and SQL injection prevention\nData Integrity: Ensuring medical records cannot be tampered with\nAudit Trail: Comprehensive logging of all security-relevant operations","security-pattern-implementation#Security Pattern Implementation":"The system implements security through two primary design patterns:\nDecorator Pattern for Authentication/Authorization\nLayered security through role-based decorators\nDynamic permission assignment and verification\nSecure user session management\nDAO Pattern for Data Access Security\nCentralized database access control\nPrepared statement usage for SQL injection prevention\nConsistent error handling and logging","uml-class-diagram#UML Class Diagram":"(You can find the High Res images in the Github Project Repo)","2-authentication-security-with-decorator-pattern#2. Authentication Security with Decorator Pattern":"","21-secure-authentication-service#2.1 Secure Authentication Service":"/**\n * AuthService handles user authentication with security considerations\n */\npublic class AuthService {\n    /**\n     * Secure login implementation with prepared statements\n     * Prevents SQL injection and implements proper error handling\n     */\n    public IUser login(String username, String password) {\n        // SECURITY: Use parameterized query to prevent SQL injection\n        String sql = \"SELECT role, doctor_id FROM staff WHERE username = ? AND password_hash = ?\";\n        try (Connection conn = DatabaseManager.getConnection();\n             PreparedStatement pstmt = conn.prepareStatement(sql)) {\n            // SECURITY: Set parameters to prevent injection attacks\n            pstmt.setString(1, username);\n            pstmt.setString(2, password); // Note: In production, this should be hashed\n            ResultSet rs = pstmt.executeQuery();\n            if (rs.next()) {\n                String role = rs.getString(\"role\");\n                String doctorId = rs.getString(\"doctor_id\");\n                // Handle NULL values safely\n                if (rs.wasNull()) {\n                    doctorId = null;\n                }\n                System.out.println(\"Login successful for user: \" + username + \" with role: \" + role);\n                return decorateUser(username, role, doctorId);\n            }\n        } catch (SQLException e) {\n            // SECURITY: Log errors without exposing sensitive information\n            System.err.println(\"Database error during login: \" + e.getMessage());\n        }\n        // SECURITY: Generic failure message to prevent user enumeration\n        System.out.println(\"Login failed for user: \" + username);\n        return null;\n    }\n    /**\n     * SECURITY: Factory method that applies appropriate security decorators\n     */\n    private IUser decorateUser(String username, String role, String doctorId) {\n        IUser user = new BaseUser(username, role, doctorId);\n        // Apply role-based security decorators\n        switch (role) {\n            case \"Doctor\":\n                return new DoctorRole(user);\n            case \"Nurse\":\n                return new NurseRole(user);\n            case \"Admin\":\n                return new AdminRole(user);\n            default:\n                // SECURITY: Return base user with minimal permissions for unknown roles\n                return user;\n        }\n    }\n}","22-secure-role-implementation#2.2 Secure Role Implementation":"/**\n * DoctorRole decorator with specific security permissions\n */\npublic class DoctorRole extends UserRoleDecorator {\n    @Override\n    public boolean hasPermission(String permission) {\n        // SECURITY: Explicit whitelist of doctor permissions\n        switch (permission) {\n            case \"can_access_appointments\":\n            case \"can_mark_appointment_done\":\n            case \"can_update_appointment\":\n            case \"can_access_patients\":\n            case \"can_add_appointment_notes\":\n                return true;\n            default:\n                // SECURITY: Delegate to parent for unknown permissions\n                return super.hasPermission(permission);\n        }\n    }\n}\n/**\n * NurseRole decorator with restricted permissions\n */\npublic class NurseRole extends UserRoleDecorator {\n    @Override\n    public boolean hasPermission(String permission) {\n        // SECURITY: Explicit permission whitelist for nurses\n        Set<String> allowedPermissions = Set.of(\n            \"can_access_patients\",\n            \"can_access_appointments\",\n            \"can_generate_reports\",\n            \"can_book_appointment\",\n            \"can_cancel_appointment\",\n            \"can_update_appointment_reason\"\n        );\n        if (allowedPermissions.contains(permission)) {\n            return true;\n        }\n        // SECURITY: Explicit denial of dangerous permissions\n        Set<String> deniedPermissions = Set.of(\n            \"can_delete_patient\",\n            \"can_delete_appointment\",\n            \"can_delete_bill\",\n            \"can_access_billing\",\n            \"can_manage_staff\"\n        );\n        if (deniedPermissions.contains(permission)) {\n            return false;\n        }\n        return super.hasPermission(permission);\n    }\n}","3-data-access-security-with-dao-pattern#3. Data Access Security with DAO Pattern":"","31-secure-patient-data-access#3.1 Secure Patient Data Access":"/**\n * PatientDAO implements secure data access patterns\n */\npublic class PatientDAO {\n    /**\n     * SECURITY: Create patient with parameterized queries\n     */\n    public boolean createPatient(PatientRecord patient) {\n        String sql = \"INSERT INTO patients (patient_id, full_name, medical_history, \" +\n                    \"treatment_plans, insurance_plan_id) VALUES (?, ?, ?, ?, ?)\";\n        try (Connection conn = DatabaseManager.getConnection();\n             PreparedStatement pstmt = conn.prepareStatement(sql)) {\n            // SECURITY: Use prepared statement parameters\n            pstmt.setString(1, patient.getPatientId());\n            pstmt.setString(2, patient.getName());\n            pstmt.setString(3, String.join(\"\\\\n\", patient.getMedicalHistory()));\n            pstmt.setString(4, String.join(\"\\\\n\", patient.getTreatmentPlans()));\n            // SECURITY: Handle NULL values safely\n            if (patient.getInsurancePlan() != null) {\n                pstmt.setInt(5, patient.getInsurancePlan().getPlanId());\n            } else {\n                pstmt.setNull(5, Types.INTEGER);\n            }\n            return pstmt.executeUpdate() > 0;\n        } catch (SQLException e) {\n            // SECURITY: Log errors without exposing sensitive patient data\n            System.err.println(\"Error creating patient: \" + e.getMessage());\n            return false;\n        }\n    }\n    /**\n     * SECURITY: Safe patient deletion with parameterized query\n     */\n    public boolean deletePatient(String patientId) {\n        String sql = \"DELETE FROM patients WHERE patient_id = ?\";\n        try (Connection conn = DatabaseManager.getConnection();\n             PreparedStatement pstmt = conn.prepareStatement(sql)) {\n            // SECURITY: Parameterized query prevents injection\n            pstmt.setString(1, patientId);\n            return pstmt.executeUpdate() > 0;\n        } catch (SQLException e) {\n            // SECURITY: Generic error logging\n            System.err.println(\"Error deleting patient: \" + e.getMessage());\n            return false;\n        }\n    }\n}","32-secure-staff-management#3.2 Secure Staff Management":"/**\n * StaffDAO with enhanced security for user account management\n */\npublic class StaffDAO {\n    /**\n     * SECURITY: Secure staff creation with duplicate prevention\n     */\n    public boolean createStaff(Staff staff) {\n        // SECURITY: Check for existing username to prevent duplicates\n        if (getStaffByUsername(staff.getUsername()) != null) {\n            System.err.println(\"Error: Staff with username '\" + staff.getUsername() + \"' already exists.\");\n            return false;\n        }\n        String sql = \"INSERT INTO staff (username, password_hash, role, doctor_id) VALUES (?, ?, ?, ?)\";\n        try (Connection conn = DatabaseManager.getConnection();\n             PreparedStatement pstmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {\n            // SECURITY: Parameterized values prevent injection\n            pstmt.setString(1, staff.getUsername());\n            pstmt.setString(2, staff.getPasswordHash()); // Should be properly hashed\n            pstmt.setString(3, staff.getRole());\n            // SECURITY: Handle optional doctor_id safely\n            if (staff.getDoctorId() != null && !staff.getDoctorId().isEmpty()) {\n                pstmt.setString(4, staff.getDoctorId());\n            } else {\n                pstmt.setNull(4, java.sql.Types.VARCHAR);\n            }\n            int affectedRows = pstmt.executeUpdate();\n            if (affectedRows > 0) {\n                // SECURITY: Update object with generated ID\n                try (ResultSet generatedKeys = pstmt.getGeneratedKeys()) {\n                    if (generatedKeys.next()) {\n                        staff.setStaffId(generatedKeys.getInt(1));\n                    }\n                }\n                return true;\n            }\n        } catch (SQLException e) {\n            // SECURITY: Log error without exposing sensitive data\n            System.err.println(\"Error creating staff: \" + e.getMessage());\n        }\n        return false;\n    }\n    /**\n     * SECURITY: Secure staff retrieval by username\n     */\n    public Staff getStaffByUsername(String username) {\n        String sql = \"SELECT staff_id, username, password_hash, role, doctor_id FROM staff WHERE username = ?\";\n        try (Connection conn = DatabaseManager.getConnection();\n             PreparedStatement pstmt = conn.prepareStatement(sql)) {\n            // SECURITY: Parameterized query\n            pstmt.setString(1, username);\n            ResultSet rs = pstmt.executeQuery();\n            if (rs.next()) {\n                return new Staff(\n                    rs.getInt(\"staff_id\"),\n                    rs.getString(\"username\"),\n                    rs.getString(\"password_hash\"),\n                    rs.getString(\"role\"),\n                    rs.getString(\"doctor_id\")\n                );\n            }\n        } catch (SQLException e) {\n            System.err.println(\"Error fetching staff by username: \" + e.getMessage());\n        }\n        return null;\n    }\n}","4-sql-injection-prevention#4. SQL Injection Prevention":"","41-consistent-prepared-statement-usage#4.1 Consistent Prepared Statement Usage":"The system consistently uses prepared statements across all DAO operations:\n// GOOD: Parameterized query prevents SQL injection\nString sql = \"SELECT * FROM patients WHERE patient_id = ?\";\ntry (Connection conn = DatabaseManager.getConnection();\n     PreparedStatement pstmt = conn.prepareStatement(sql)) {\n    pstmt.setString(1, patientId);\n    ResultSet rs = pstmt.executeQuery();\n    // Process results...\n}\n// BAD: String concatenation vulnerable to injection (NOT used in system)\n// String sql = \"SELECT * FROM patients WHERE patient_id = '\" + patientId + \"'\";","42-safe-parameter-handling#4.2 Safe Parameter Handling":"/**\n * Example of safe parameter handling in BillingDAO\n */\npublic int saveBill(MedicalBill bill) {\n    String sql = \"INSERT INTO billing (bill_id, patient_id, service_description, amount, \" +\n                \"status, processing_log, final_amount, insurance_policy_number, \" +\n                \"billed_datetime, amount_paid, insurance_paid_amount) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\";\n    try (Connection conn = DatabaseManager.getConnection();\n         PreparedStatement pstmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {\n        // SECURITY: All parameters are safely set\n        if (bill.getBillId() == 0) {\n            pstmt.setNull(1, java.sql.Types.INTEGER);\n        } else {\n            pstmt.setInt(1, bill.getBillId());\n        }\n        pstmt.setString(2, bill.getPatientId());\n        pstmt.setString(3, bill.getServiceDescription());\n        pstmt.setDouble(4, bill.getAmount());\n        pstmt.setString(5, bill.getStatus());\n        pstmt.setString(6, bill.getProcessingLog());\n        pstmt.setDouble(7, bill.getFinalAmount());\n        // SECURITY: Handle nullable insurance plan safely\n        pstmt.setString(8, bill.getAppliedInsurancePlan() != null ?\n                       bill.getAppliedInsurancePlan().getPlanName() : null);\n        // SECURITY: Safe timestamp handling\n        if (bill.getBilledDateTime() != null) {\n            pstmt.setTimestamp(9, Timestamp.valueOf(bill.getBilledDateTime()));\n        } else {\n            pstmt.setTimestamp(9, Timestamp.valueOf(LocalDateTime.now()));\n        }\n        pstmt.setDouble(10, bill.getAmountPaid());\n        pstmt.setDouble(11, bill.getInsurancePaidAmount());\n        return pstmt.executeUpdate();\n    } catch (SQLException e) {\n        System.err.println(\"Error saving bill: \" + e.getMessage());\n        return -1;\n    }\n}","5-role-based-access-control-security#5. Role-Based Access Control Security":"","51-permission-enforcement-in-controllers#5.1 Permission Enforcement in Controllers":"/**\n * Example of RBAC implementation in patient management\n */\nprivate void deletePatient() {\n    // SECURITY: Check permissions before any operation\n    if (!currentUser.hasPermission(\"can_delete_patient\")) {\n        JOptionPane.showMessageDialog(view,\n            \"You do not have permission to delete patient records.\",\n            \"Access Denied\", JOptionPane.ERROR_MESSAGE);\n        return;\n    }\n    if (currentPatient == null) return;\n    // SECURITY: Confirmation dialog for destructive operations\n    int response = JOptionPane.showConfirmDialog(view,\n        \"Are you sure you want to delete patient \" + currentPatient.getName() + \"?\",\n        \"Confirm Deletion\", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);\n    if (response == JOptionPane.YES_OPTION) {\n        boolean success = dao.deletePatient(currentPatient.getPatientId());\n        if (success) {\n            JOptionPane.showMessageDialog(view, \"Patient deleted successfully.\",\n                \"Success\", JOptionPane.INFORMATION_MESSAGE);\n            view.clearFields();\n        } else {\n            JOptionPane.showMessageDialog(view, \"Failed to delete patient.\",\n                \"Error\", JOptionPane.ERROR_MESSAGE);\n        }\n    }\n}\n/**\n * SECURITY: Staff management with administrative permissions\n */\nprivate void addStaff() {\n    if (!currentUser.hasPermission(\"can_manage_staff\")) {\n        JOptionPane.showMessageDialog(mainFrame,\n            \"You do not have permission to add staff members.\",\n            \"Access Denied\", JOptionPane.ERROR_MESSAGE);\n        return;\n    }\n    // Proceed with staff creation...\n}","52-context-aware-security-checks#5.2 Context-Aware Security Checks":"/**\n * Example of context-aware security in appointment management\n */\nprivate void updatePrescription() {\n    // SECURITY: Multiple layers of permission checking\n    if (!currentUser.hasPermission(\"can_add_appointment_notes\")) {\n        JOptionPane.showMessageDialog(mainFrame,\n            \"You do not have permission to update prescriptions.\",\n            \"Access Denied\", JOptionPane.ERROR_MESSAGE);\n        return;\n    }\n    Appointment selectedAppointment = view.getSelectedAppointment(currentAppointments);\n    if (selectedAppointment == null) {\n        JOptionPane.showMessageDialog(view,\n            \"Please select an appointment to update prescription.\",\n            \"Warning\", JOptionPane.WARNING_MESSAGE);\n        return;\n    }\n    // SECURITY: Ownership verification for doctors\n    if (currentUser.getDoctorId() == null ||\n        !currentUser.getDoctorId().equals(selectedAppointment.getDoctorId())) {\n        JOptionPane.showMessageDialog(mainFrame,\n            \"You can only update prescriptions for your own appointments.\",\n            \"Access Denied\", JOptionPane.ERROR_MESSAGE);\n        return;\n    }\n    // SECURITY: Status validation\n    if (\"Canceled\".equalsIgnoreCase(selectedAppointment.getStatus())) {\n        JOptionPane.showMessageDialog(view,\n            \"Cannot update prescription for canceled appointments.\",\n            \"Invalid Operation\", JOptionPane.WARNING_MESSAGE);\n        return;\n    }\n    // Proceed with prescription update...\n}","6-database-security-implementation#6. Database Security Implementation":"","61-database-schema-security-features#6.1 Database Schema Security Features":"The database schema implements several security features:\n-- SECURITY: Foreign key constraints prevent orphaned records\nCREATE TABLE `staff` (\n  `staff_id` int NOT NULL AUTO_INCREMENT,\n  `username` varchar(50) NOT NULL,\n  `password_hash` varchar(255) NOT NULL,  -- Stores hashed passwords\n  `role` varchar(50) NOT NULL,\n  `doctor_id` varchar(50) DEFAULT NULL,\n  PRIMARY KEY (`staff_id`),\n  UNIQUE KEY `username` (`username`),    -- Prevents duplicate usernames\n  KEY `doctor_id` (`doctor_id`),\n  CONSTRAINT `fk_staff_doctor_id` FOREIGN KEY (`doctor_id`)\n    REFERENCES `doctors` (`doctor_id`) ON DELETE SET NULL\n) ENGINE=InnoDB;\n-- SECURITY: Patient data with insurance plan constraints\nCREATE TABLE `patients` (\n  `patient_id` varchar(50) NOT NULL,\n  `full_name` varchar(255) NOT NULL,\n  `medical_history` text,\n  `treatment_plans` text,\n  `insurance_plan_id` int DEFAULT NULL,\n  PRIMARY KEY (`patient_id`),\n  KEY `insurance_plan_id` (`insurance_plan_id`),\n  CONSTRAINT `patients_ibfk_1` FOREIGN KEY (`insurance_plan_id`)\n    REFERENCES `insurance_plans` (`plan_id`)\n) ENGINE=InnoDB;","62-connection-security#6.2 Connection Security":"/**\n * Note: The current implementation shows basic connection management\n * In production, this should include:\n * - Connection pooling for performance and security\n * - SSL/TLS encryption for data in transit\n * - Proper credential management (not hardcoded)\n */\npublic class DatabaseManager {\n    // SECURITY CONCERN: Credentials should not be hardcoded\n    private static final String JDBC_URL = \"jdbc:mysql://localhost:3306/globemed_db\";\n    private static final String USERNAME = \"root\";\n    private static final String PASSWORD = \"your_password\";\n    public static Connection getConnection() throws SQLException {\n        if (connection == null || connection.isClosed()) {\n            try {\n                Class.forName(\"com.mysql.cj.jdbc.Driver\");\n                connection = DriverManager.getConnection(JDBC_URL, USERNAME, PASSWORD);\n                System.out.println(\"Database connection successful!\");\n            } catch (ClassNotFoundException e) {\n                System.err.println(\"MySQL JDBC Driver not found.\");\n                throw new SQLException(\"JDBC Driver not found\", e);\n            }\n        }\n        return connection;\n    }\n}","7-security-vulnerabilities--mitigations#7. Security Vulnerabilities & Mitigations":"","71-current-security-vulnerabilities#7.1 Current Security Vulnerabilities":"1. Password Storage\nVulnerability: Passwords appear to be stored as plain text or simple hashes\nEvidence: password_hash field contains values like \"1101\" in sample data\nRisk: High - Compromised database exposes all user credentials\n2. Database Credentials\nVulnerability: Database credentials hardcoded in source code\nRisk: Medium - Source code access exposes database credentials\n3. No Connection Encryption\nVulnerability: Database connections not encrypted\nRisk: Medium - Data in transit vulnerable to interception\n4. Limited Session Management\nVulnerability: No apparent session timeout or management\nRisk: Medium - Session hijacking possibilities","72-recommended-security-mitigations#7.2 Recommended Security Mitigations":"1. Implement Proper Password Hashing\n/**\n * RECOMMENDED: Secure password hashing implementation\n */\npublic class PasswordSecurity {\n    private static final BCryptPasswordEncoder encoder = new BCryptPasswordEncoder(12);\n    public static String hashPassword(String plainPassword) {\n        return encoder.encode(plainPassword);\n    }\n    public static boolean verifyPassword(String plainPassword, String hashedPassword) {\n        return encoder.matches(plainPassword, hashedPassword);\n    }\n}\n// Updated AuthService login method\npublic IUser login(String username, String password) {\n    String sql = \"SELECT role, doctor_id, password_hash FROM staff WHERE username = ?\";\n    try (Connection conn = DatabaseManager.getConnection();\n         PreparedStatement pstmt = conn.prepareStatement(sql)) {\n        pstmt.setString(1, username);\n        ResultSet rs = pstmt.executeQuery();\n        if (rs.next()) {\n            String storedHash = rs.getString(\"password_hash\");\n            // SECURITY: Verify password against hash\n            if (PasswordSecurity.verifyPassword(password, storedHash)) {\n                String role = rs.getString(\"role\");\n                String doctorId = rs.getString(\"doctor_id\");\n                return decorateUser(username, role, doctorId);\n            }\n        }\n    } catch (SQLException e) {\n        System.err.println(\"Database error during login: \" + e.getMessage());\n    }\n    return null;\n}\n2. Environment-Based Configuration\n/**\n * RECOMMENDED: Secure configuration management\n */\npublic class DatabaseManager {\n    private static final String JDBC_URL = System.getenv(\"DB_URL\");\n    private static final String USERNAME = System.getenv(\"DB_USERNAME\");\n    private static final String PASSWORD = System.getenv(\"DB_PASSWORD\");\n    public static Connection getConnection() throws SQLException {\n        if (JDBC_URL == null || USERNAME == null || PASSWORD == null) {\n            throw new SQLException(\"Database configuration not properly set\");\n        }\n        // Add SSL parameters for encrypted connections\n        String secureUrl = JDBC_URL + \"?useSSL=true&requireSSL=true&verifyServerCertificate=true\";\n        return DriverManager.getConnection(secureUrl, USERNAME, PASSWORD);\n    }\n}\n3. Session Management Enhancement\n/**\n * RECOMMENDED: Secure session management\n */\npublic class SessionManager {\n    private static final Map<String, UserSession> activeSessions = new ConcurrentHashMap<>();\n    private static final long SESSION_TIMEOUT = 30 * 60 * 1000; // 30 minutes\n    public static class UserSession {\n        private final IUser user;\n        private final long createdTime;\n        private long lastAccessTime;\n        public UserSession(IUser user) {\n            this.user = user;\n            this.createdTime = System.currentTimeMillis();\n            this.lastAccessTime = createdTime;\n        }\n        public boolean isValid() {\n            long currentTime = System.currentTimeMillis();\n            return (currentTime - lastAccessTime) < SESSION_TIMEOUT;\n        }\n        public void updateAccess() {\n            this.lastAccessTime = System.currentTimeMillis();\n        }\n    }\n    public static String createSession(IUser user) {\n        String sessionId = UUID.randomUUID().toString();\n        activeSessions.put(sessionId, new UserSession(user));\n        return sessionId;\n    }\n    public static IUser getUser(String sessionId) {\n        UserSession session = activeSessions.get(sessionId);\n        if (session != null && session.isValid()) {\n            session.updateAccess();\n            return session.user;\n        } else {\n            activeSessions.remove(sessionId);\n            return null;\n        }\n    }\n}","8-security-best-practices-implemented#8. Security Best Practices Implemented":"","81-positive-security-features#8.1 Positive Security Features":"1. Consistent Use of Prepared Statements\nAll database operations use parameterized queries\nPrevents SQL injection attacks across the entire application\nProper handling of NULL values and data types\n2. Role-Based Access Control\nClear separation of permissions by user role\nExplicit permission checking before sensitive operations\nDecorator pattern enables flexible permission management\n3. Input Validation and Error Handling\nProper validation of user inputs before database operations\nGeneric error messages to prevent information disclosure\nConsistent error logging without exposing sensitive data\n4. Database Integrity Constraints\nForeign key constraints prevent data corruption\nUnique constraints prevent duplicate critical data\nProper use of NOT NULL constraints for required fields","82-security-architecture-benefits#8.2 Security Architecture Benefits":"1. Defense in Depth\nMultiple layers of security (authentication, authorization, data access)\nPermission checks at both UI and business logic levels\nDatabase constraints as final layer of protection\n2. Principle of Least Privilege\nUsers only receive minimum necessary permissions\nRole-based restrictions properly implemented\nContext-aware permission checking (e.g., doctors can only modify their own appointments)\n3. Secure by Default\nBase users have no permissions by default\nUnknown roles receive minimal access\nExplicit permission grants rather than denials\n4. Audit and Logging\nComprehensive logging of authentication attempts\nError logging for security monitoring\nUser action tracking for audit trails","83-recommended-security-enhancements#8.3 Recommended Security Enhancements":"1. Immediate Priority\nImplement proper password hashing (bcrypt/scrypt)\nMove database credentials to environment variables\nAdd SSL/TLS encryption for database connections\nImplement session timeout management\n2. Medium Priority\nAdd comprehensive audit logging\nImplement rate limiting for login attempts\nAdd input sanitization beyond SQL injection prevention\nCreate security configuration management\n3. Long-term Security\nImplement multi-factor authentication\nAdd encryption for sensitive data at rest\nCreate comprehensive security testing framework\nImplement automated security monitoring","9-conclusion#9. Conclusion":"The GlobeMed Healthcare Management System demonstrates a solid foundation for security through the strategic use of the Decorator and DAO patterns. The Decorator pattern provides flexible and extensible role-based access control, while the DAO pattern ensures consistent and secure data access practices throughout the application.","security-strengths#Security Strengths":"Comprehensive SQL Injection Prevention: Consistent use of prepared statements across all database operations provides strong protection against injection attacks.\nRobust Role-Based Access Control: The Decorator pattern implementation enables fine-grained permission management with clear separation between different user roles.\nSecure Data Access Patterns: The DAO pattern centralizes database operations and ensures consistent security practices across all data access points.\nDefense in Depth: Multiple layers of security checking from UI controls through business logic to database constraints.","critical-security-improvements-needed#Critical Security Improvements Needed":"While the architectural foundation is strong, several critical security enhancements are required for production deployment:\nPassword Security: Implementation of proper cryptographic hashing for password storage\nConfiguration Security: Migration of hardcoded credentials to secure configuration management\nTransport Security: Addition of SSL/TLS encryption for all database communications\nSession Management: Implementation of secure session handling with appropriate timeouts\nThe current implementation provides an excellent foundation that, with the recommended security enhancements, would meet healthcare industry security standards and regulatory requirements such as HIPAA compliance.Document Status: Part F Complete - Security AnalysisPattern Analysis Series: Complete (Parts A-F) - All major design patterns and security considerations analyzed"}},"/staff-permissions":{"title":"Staff Roles & Permissions","data":{"":"Document: Part D AnalysisPattern: Decorator PatternModule: Medical Staff Roles and Permissions SystemAuthor: Ishara Lakshitha","table-of-contents#Table of Contents":"","1-overview--problem-statement#1. Overview & Problem Statement":"","healthcare-domain-problems-addressed#Healthcare Domain Problems Addressed":"Problem 1: Complex Role-Based Access Control\nHealthcare systems require sophisticated permission management\nDifferent medical staff roles have distinct access privileges\nPermissions must be granular for patient safety and regulatory compliance\nNeed flexible system to add new roles or modify existing permissions\nProblem 2: Hierarchical Permission Structure\nMedical staff roles have overlapping but distinct responsibilities\nDoctors can perform medical procedures but have limited administrative access\nNurses have patient care permissions but cannot perform certain medical functions\nAdministrators have system-wide access but limited clinical permissions\nProblem 3: Dynamic Permission Assignment\nStaff members may have multiple roles or temporary elevated permissions\nNeed to combine permissions from different roles dynamically\nMust maintain audit trail of permission usage\nSystem should support role delegation and temporary access","solution-approach#Solution Approach":"The Decorator Pattern provides a flexible permission system where:\nBaseUser serves as the core component with minimal permissions\nRole Decorators (DoctorRole, NurseRole, AdminRole) add specific permissions\nDynamic Composition allows combining multiple roles if needed\nExtensible Architecture supports adding new roles without modifying existing code","2-decorator-pattern-implementation#2. Decorator Pattern Implementation":"","21-pattern-participants#2.1 Pattern Participants":"","component-interface#Component Interface":"/**\n * The Component interface for the Decorator pattern.\n * Defines the operations that can be altered by decorators.\n */\npublic interface IUser {\n    String getUsername();\n    String getRole();\n    String getDoctorId();\n    boolean hasPermission(String permission);\n}","concrete-component#Concrete Component":"/**\n * The Concrete Component. A base user object that represents a\n * logged-in user with basic information but no special permissions.\n */\npublic class BaseUser implements IUser {\n    private final String username;\n    private final String role;\n    private final String doctorId;\n    public BaseUser(String username, String role, String doctorId) {\n        this.username = username;\n        this.role = role;\n        this.doctorId = doctorId;\n    }\n    @Override\n    public String getUsername() { return this.username; }\n    @Override\n    public String getRole() { return this.role; }\n    @Override\n    public String getDoctorId() { return this.doctorId; }\n    @Override\n    public boolean hasPermission(String permission) {\n        return false; // Base user has no permissions\n    }\n}","abstract-decorator#Abstract Decorator":"/**\n * The abstract Decorator class. It holds a reference to a component object\n * and delegates all requests to it. Its main purpose is to define a\n * wrapping interface for all concrete decorators.\n */\npublic abstract class UserRoleDecorator implements IUser {\n    protected final IUser wrappedUser;\n    public UserRoleDecorator(IUser user) {\n        this.wrappedUser = user;\n    }\n    @Override\n    public String getUsername() {\n        return wrappedUser.getUsername();\n    }\n    @Override\n    public String getRole() {\n        return wrappedUser.getRole();\n    }\n    @Override\n    public String getDoctorId() {\n        return wrappedUser.getDoctorId();\n    }\n    @Override\n    public boolean hasPermission(String permission) {\n        // Delegate to the wrapped user by default.\n        // Concrete decorators will override this.\n        return wrappedUser.hasPermission(permission);\n    }\n}","concrete-decorator-1-doctorrole#Concrete Decorator 1: DoctorRole":"/**\n * Decorator that adds doctor-specific permissions\n */\npublic class DoctorRole extends UserRoleDecorator {\n    public DoctorRole(IUser user) {\n        super(user);\n    }\n    @Override\n    public boolean hasPermission(String permission) {\n        // Doctor-specific permissions\n        if (\"can_access_appointments\".equals(permission) ||\n            \"can_mark_appointment_done\".equals(permission) ||\n            \"can_update_appointment\".equals(permission) ||\n            \"can_access_patients\".equals(permission) ||\n            \"can_add_appointment_notes\".equals(permission)) {\n            return true;\n        }\n        // Delegate to wrapped user for other permissions\n        return super.hasPermission(permission);\n    }\n}","concrete-decorator-2-nurserole#Concrete Decorator 2: NurseRole":"/**\n * Decorator that adds nurse-specific permissions\n */\npublic class NurseRole extends UserRoleDecorator {\n    public NurseRole(IUser user) {\n        super(user);\n    }\n    @Override\n    public boolean hasPermission(String permission) {\n        // Nurse-specific permissions\n        if (\"can_access_patients\".equals(permission) ||\n            \"can_access_appointments\".equals(permission) ||\n            \"can_generate_reports\".equals(permission) ||\n            \"can_book_appointment\".equals(permission) ||\n            \"can_cancel_appointment\".equals(permission) ||\n            \"can_update_appointment_reason\".equals(permission)) {\n            return true;\n        }\n        // Nurses explicitly DO NOT have these permissions:\n        // \"can_delete_patient\", \"can_delete_appointment\", \"can_delete_bill\",\n        // \"can_mark_appointment_done\", \"can_access_billing\", \"can_view_all_patients\"\n        return super.hasPermission(permission);\n    }\n}","concrete-decorator-3-adminrole#Concrete Decorator 3: AdminRole":"/**\n * Decorator that grants administrative permissions\n */\npublic class AdminRole extends UserRoleDecorator {\n    public AdminRole(IUser user) {\n        super(user);\n    }\n    @Override\n    public boolean hasPermission(String permission) {\n        // Admins have all permissions\n        return true;\n    }\n}","22-factory-method-for-user-decoration#2.2 Factory Method for User Decoration":"/**\n * AuthService handles user authentication and role decoration\n */\npublic class AuthService {\n    public IUser login(String username, String password) {\n        // Database authentication logic\n        String sql = \"SELECT role, doctor_id FROM staff WHERE username = ? AND password_hash = ?\";\n        try (Connection conn = DatabaseManager.getConnection();\n             PreparedStatement pstmt = conn.prepareStatement(sql)) {\n            pstmt.setString(1, username);\n            pstmt.setString(2, password);\n            ResultSet rs = pstmt.executeQuery();\n            if (rs.next()) {\n                String role = rs.getString(\"role\");\n                String doctorId = rs.getString(\"doctor_id\");\n                if (rs.wasNull()) {\n                    doctorId = null;\n                }\n                System.out.println(\"Login successful for user: \" + username +\n                                 \" with role: \" + role +\n                                 (doctorId != null ? \" (Doctor ID: \" + doctorId + \")\" : \"\"));\n                return decorateUser(username, role, doctorId);\n            }\n        } catch (SQLException e) {\n            System.err.println(\"Database error during login: \" + e.getMessage());\n        }\n        return null;\n    }\n    /**\n     * Factory method to construct the appropriate decorated user object.\n     */\n    private IUser decorateUser(String username, String role, String doctorId) {\n        // Create base user\n        IUser user = new BaseUser(username, role, doctorId);\n        // Apply role-specific decorator\n        switch (role) {\n            case \"Doctor\":\n                return new DoctorRole(user);\n            case \"Nurse\":\n                return new NurseRole(user);\n            case \"Admin\":\n                return new AdminRole(user);\n            default:\n                return user; // Return base user with no additional permissions\n        }\n    }\n}","3-uml-class-diagrams#3. UML Class Diagrams":"","30-comprehensive-diagram#3.0 Comprehensive Diagram":"(You can find the High Res images in the Github Project Repo)","31-decorator-pattern-structure#3.1 Decorator Pattern Structure":"┌─────────────────────────────────────┐\n│           <<interface>>             │\n│              IUser                  │\n├─────────────────────────────────────┤\n│ + getUsername(): String             │\n│ + getRole(): String                 │\n│ + getDoctorId(): String             │\n│ + hasPermission(permission): boolean│\n└─────────────────────────────────────┘\n                    ▲\n        ┌───────────┼───────────┐\n        │           │           │\n┌───────────────┐ ┌─────────────────────────────────────┐\n│   BaseUser    │ │      UserRoleDecorator              │\n│  (Component)  │ │     (Abstract Decorator)            │\n├───────────────┤ ├─────────────────────────────────────┤\n│- username     │ │# wrappedUser: IUser                 │\n│- role         │ ├─────────────────────────────────────┤\n│- doctorId     │ │+ getUsername(): String              │\n├───────────────┤ │+ getRole(): String                  │\n│+ getUsername()│ │+ getDoctorId(): String              │\n│+ getRole()    │ │+ hasPermission(permission): boolean │\n│+ getDoctorId()│ └─────────────────────────────────────┘\n│+ hasPermission│                     ▲\n│  (): boolean  │           ┌─────────┼─────────┐\n└───────────────┘           │         │         │\n                    ┌───────────┐ ┌─────────┐ ┌─────────┐\n                    │DoctorRole │ │NurseRole│ │AdminRole│\n                    │(Concrete  │ │(Concrete│ │(Concrete│\n                    │Decorator) │ │Decorator│ │Decorator│\n                    ├───────────┤ ├─────────┤ ├─────────┤\n                    │+ has      │ │+ has    │ │+ has    │\n                    │Permission │ │Permission│ │Permission│\n                    │(): boolean│ │(): bool │ │(): bool │\n                    └───────────┘ └─────────┘ └─────────┘","32-permission-flow-diagram#3.2 Permission Flow Diagram":"Client Request → Controller → IUser.hasPermission() → Decorator Chain\nExample: Doctor updating appointment notes\nAppointmentController.updatePrescription()\n            │\n            ▼\ncurrentUser.hasPermission(\"can_add_appointment_notes\")\n            │\n            ▼\nDoctorRole.hasPermission(\"can_add_appointment_notes\")\n            │\n            ├─→ \"can_add_appointment_notes\" found in doctor permissions\n            │                    │\n            │                    ▼\n            │               return true\n            │\n            └─→ (if not found) super.hasPermission(permission)\n                                │\n                                ▼\n                        BaseUser.hasPermission() → return false","4-detailed-code-analysis#4. Detailed Code Analysis":"","41-permission-grant-matrix#4.1 Permission Grant Matrix":"Permission\tDoctor\tNurse\tAdmin\tDescription\tcan_access_patients\t✓\t✓\t✓\tView patient records\tcan_access_appointments\t✓\t✓\t✓\tView appointment schedules\tcan_book_appointment\t✗\t✓\t✓\tSchedule new appointments\tcan_cancel_appointment\t✗\t✓\t✓\tCancel existing appointments\tcan_update_appointment_reason\t✗\t✓\t✓\tModify appointment reasons\tcan_mark_appointment_done\t✓\t✗\t✓\tMark appointments as completed\tcan_add_appointment_notes\t✓\t✗\t✓\tAdd/edit medical notes\tcan_delete_patient\t✗\t✗\t✓\tRemove patient records\tcan_delete_appointment\t✗\t✗\t✓\tPermanently delete appointments\tcan_manage_doctors\t✗\t✗\t✓\tCRUD operations on doctor records\tcan_manage_staff\t✗\t✗\t✓\tCRUD operations on staff records\tcan_access_billing\t✗\t✗\t✓\tAccess billing information\tcan_process_payments\t✗\t✗\t✓\tProcess patient payments\tcan_generate_reports\t✗\t✓\t✓\tGenerate system reports","42-controller-integration-examples#4.2 Controller Integration Examples":"","patient-controller-permission-usage#Patient Controller Permission Usage":"public class PatientController {\n    private final IUser currentUser;\n    private void initController() {\n        // View all patients permission check\n        view.viewAllButton.setEnabled(currentUser.hasPermission(\"can_view_all_patients\"));\n    }\n    private void deletePatient() {\n        if (!currentUser.hasPermission(\"can_delete_patient\")) {\n            JOptionPane.showMessageDialog(view,\n                \"You do not have permission to delete patient records.\",\n                \"Access Denied\", JOptionPane.ERROR_MESSAGE);\n            return;\n        }\n        // Proceed with deletion logic\n    }\n}","appointment-controller-permission-usage#Appointment Controller Permission Usage":"public class AppointmentController {\n    private void applyPermissions() {\n        // Doctor-specific access based on doctor ID\n        view.viewScheduleButton.setEnabled(\n            currentUser.getDoctorId() != null ||\n            (view.doctorsTable.getSelectedRow() != -1 &&\n             currentUser.hasPermission(\"can_access_appointments\"))\n        );\n        // General appointment permissions\n        view.viewAllAppointmentsButton.setEnabled(\n            currentUser.hasPermission(\"can_access_appointments\")\n        );\n        view.bookAppointmentButton.setEnabled(\n            currentUser.hasPermission(\"can_book_appointment\")\n        );\n        // Administrative permissions\n        boolean canManageDoctors = currentUser.hasPermission(\"can_manage_doctors\");\n        view.setDoctorCrudFieldsEditable(canManageDoctors);\n        view.addDoctorButton.setEnabled(canManageDoctors);\n    }\n    private void updateButtonStatesBasedOnSelection() {\n        Appointment selectedAppt = view.getSelectedAppointment(currentAppointments);\n        if (selectedAppt == null) return;\n        String status = selectedAppt.getStatus();\n        boolean isOwner = currentUser.getDoctorId() != null &&\n                         currentUser.getDoctorId().equals(selectedAppt.getDoctorId());\n        boolean isDoctor = currentUser.getDoctorId() != null;\n        boolean isNurseOrAdmin = !isDoctor;\n        // Nurse/Admin can update appointment reasons for scheduled appointments\n        boolean canUpdateReason = currentUser.hasPermission(\"can_update_appointment_reason\") &&\n                                 isNurseOrAdmin &&\n                                 \"Scheduled\".equalsIgnoreCase(status);\n        view.updateAppointmentButton.setEnabled(canUpdateReason);\n        // Doctors can add notes to their own appointments\n        boolean canUpdatePrescription = currentUser.hasPermission(\"can_add_appointment_notes\") &&\n                                       isOwner && isDoctor &&\n                                       !\"Canceled\".equalsIgnoreCase(status);\n        view.updatePrescriptionButton.setEnabled(canUpdatePrescription);\n        // Cancel permissions based on role and ownership\n        boolean canCancel = currentUser.hasPermission(\"can_cancel_appointment\") &&\n                           !\"Done\".equalsIgnoreCase(status) &&\n                           !\"Canceled\".equalsIgnoreCase(status) &&\n                           (isOwner || isNurseOrAdmin);\n        view.cancelAppointmentButton.setEnabled(canCancel);\n    }\n}","staff-controller-permission-usage#Staff Controller Permission Usage":"public class StaffController {\n    private void applyPermissions() {\n        boolean canManageStaff = currentUser.hasPermission(\"can_manage_staff\");\n        boolean isStaffSelected = view.staffTable.getSelectedRow() != -1;\n        // Enable/disable form fields based on permissions\n        view.setFormEditable(canManageStaff);\n        view.refreshStaffButton.setEnabled(canManageStaff);\n        // CRUD button permissions\n        view.addButton.setEnabled(canManageStaff && !isStaffSelected);\n        view.updateButton.setEnabled(canManageStaff && isStaffSelected);\n        view.deleteButton.setEnabled(canManageStaff && isStaffSelected);\n    }\n    private void addStaff() {\n        if (!currentUser.hasPermission(\"can_manage_staff\")) {\n            JOptionPane.showMessageDialog(mainFrame,\n                \"You do not have permission to add staff members.\",\n                \"Access Denied\", JOptionPane.ERROR_MESSAGE);\n            return;\n        }\n        // Proceed with staff addition logic\n    }\n}","43-dynamic-permission-checking#4.3 Dynamic Permission Checking":"/**\n * Example of dynamic permission checking in appointment booking\n */\nprivate void bookNewAppointment() {\n    if (!currentUser.hasPermission(\"can_book_appointment\")) {\n        JOptionPane.showMessageDialog(mainFrame,\n            \"You do not have permission to book appointments.\",\n            \"Access Denied\", JOptionPane.ERROR_MESSAGE);\n        return;\n    }\n    // For doctors, automatically select their own profile\n    Doctor selectedDoctor = null;\n    if (currentUser.getDoctorId() != null) {\n        // Doctor can only book appointments for themselves\n        for (Doctor doc : currentDoctors) {\n            if (doc.getDoctorId().equals(currentUser.getDoctorId())) {\n                selectedDoctor = doc;\n                break;\n            }\n        }\n        if (selectedDoctor == null) {\n            JOptionPane.showMessageDialog(mainFrame,\n                \"Your staff account's doctor ID is not linked to an active doctor profile. \" +\n                \"Please contact admin.\", \"Configuration Error\", JOptionPane.ERROR_MESSAGE);\n            return;\n        }\n    } else {\n        // Non-doctors (nurses/admins) can select any doctor\n        selectedDoctor = view.getSelectedDoctor(currentDoctors);\n        if (selectedDoctor == null) {\n            JOptionPane.showMessageDialog(view,\n                \"Please select a doctor first.\", \"Validation Error\", JOptionPane.ERROR_MESSAGE);\n            return;\n        }\n    }\n    // Continue with booking logic...\n}","5-permission-management-system#5. Permission Management System":"","51-role-specific-permission-implementation#5.1 Role-Specific Permission Implementation":"","doctor-role-permissions#Doctor Role Permissions":"public class DoctorRole extends UserRoleDecorator {\n    @Override\n    public boolean hasPermission(String permission) {\n        switch (permission) {\n            case \"can_access_appointments\":\n                return true; // Doctors can view appointment schedules\n            case \"can_mark_appointment_done\":\n                return true; // Doctors can mark their appointments as completed\n            case \"can_update_appointment\":\n                return true; // Doctors can modify appointment details\n            case \"can_access_patients\":\n                return true; // Doctors can access patient records\n            case \"can_add_appointment_notes\":\n                return true; // Doctors can add medical notes and prescriptions\n            default:\n                return super.hasPermission(permission);\n        }\n    }\n}","nurse-role-permissions#Nurse Role Permissions":"public class NurseRole extends UserRoleDecorator {\n    @Override\n    public boolean hasPermission(String permission) {\n        // Permissions nurses HAVE\n        Set<String> nursePermissions = Set.of(\n            \"can_access_patients\",\n            \"can_access_appointments\",\n            \"can_generate_reports\",\n            \"can_book_appointment\",\n            \"can_cancel_appointment\",\n            \"can_update_appointment_reason\"\n        );\n        if (nursePermissions.contains(permission)) {\n            return true;\n        }\n        // Permissions nurses explicitly DO NOT have\n        Set<String> restrictedPermissions = Set.of(\n            \"can_delete_patient\",\n            \"can_delete_appointment\",\n            \"can_delete_bill\",\n            \"can_mark_appointment_done\",\n            \"can_access_billing\",\n            \"can_view_all_patients\",\n            \"can_manage_staff\",\n            \"can_manage_doctors\"\n        );\n        if (restrictedPermissions.contains(permission)) {\n            return false;\n        }\n        return super.hasPermission(permission);\n    }\n}","admin-role-permissions#Admin Role Permissions":"public class AdminRole extends UserRoleDecorator {\n    @Override\n    public boolean hasPermission(String permission) {\n        // Admins have all permissions - no restrictions\n        return true;\n    }\n}","52-context-aware-permission-checking#5.2 Context-Aware Permission Checking":"/**\n * Example of context-aware permission checking for appointment updates\n */\nprivate void updatePrescription() {\n    if (!currentUser.hasPermission(\"can_add_appointment_notes\")) {\n        JOptionPane.showMessageDialog(mainFrame,\n            \"You do not have permission to update prescriptions.\",\n            \"Access Denied\", JOptionPane.ERROR_MESSAGE);\n        return;\n    }\n    Appointment selectedAppointment = view.getSelectedAppointment(currentAppointments);\n    if (selectedAppointment == null) {\n        JOptionPane.showMessageDialog(view,\n            \"Please select an appointment to update prescription.\",\n            \"Warning\", JOptionPane.WARNING_MESSAGE);\n        return;\n    }\n    // Additional context check: Only doctors can update their own appointment prescriptions\n    if (currentUser.getDoctorId() == null ||\n        !currentUser.getDoctorId().equals(selectedAppointment.getDoctorId())) {\n        JOptionPane.showMessageDialog(mainFrame,\n            \"You can only update prescriptions for your own appointments.\",\n            \"Access Denied\", JOptionPane.ERROR_MESSAGE);\n        return;\n    }\n    // Check appointment status\n    if (\"Canceled\".equalsIgnoreCase(selectedAppointment.getStatus())) {\n        JOptionPane.showMessageDialog(view,\n            \"Cannot update prescription for canceled appointments.\",\n            \"Invalid Operation\", JOptionPane.WARNING_MESSAGE);\n        return;\n    }\n    // Proceed with prescription update\n}","53-permission-hierarchies-and-combinations#5.3 Permission Hierarchies and Combinations":"/**\n * Example showing how different roles interact with the same feature\n */\nprivate void markSelectedAppointmentAsDone() {\n    if (!currentUser.hasPermission(\"can_mark_appointment_done\")) {\n        JOptionPane.showMessageDialog(mainFrame,\n            \"You do not have permission to mark appointments as done.\",\n            \"Access Denied\", JOptionPane.ERROR_MESSAGE);\n        return;\n    }\n    Appointment selectedAppointment = view.getSelectedAppointment(currentAppointments);\n    if (selectedAppointment == null) {\n        JOptionPane.showMessageDialog(view,\n            \"Please select an appointment to mark as done.\",\n            \"Warning\", JOptionPane.WARNING_MESSAGE);\n        return;\n    }\n    // Context-specific rules based on role\n    if (currentUser.getDoctorId() != null) {\n        // Doctors can only mark their own appointments as done\n        if (!currentUser.getDoctorId().equals(selectedAppointment.getDoctorId())) {\n            JOptionPane.showMessageDialog(mainFrame,\n                \"You can only mark your own appointments as done.\",\n                \"Access Denied\", JOptionPane.ERROR_MESSAGE);\n            return;\n        }\n    }\n    // Admins can mark any appointment as done (no additional restrictions)\n    // Status validation\n    if (\"Done\".equalsIgnoreCase(selectedAppointment.getStatus())) {\n        JOptionPane.showMessageDialog(view,\n            \"Appointment is already marked as Done.\",\n            \"Information\", JOptionPane.INFORMATION_MESSAGE);\n        return;\n    }\n    // Proceed with marking appointment as done\n}","6-usage-scenarios#6. Usage Scenarios":"","61-scenario-1-doctor-login-and-permissions#6.1 Scenario 1: Doctor Login and Permissions":"// Login process for a doctor\nAuthService authService = new AuthService();\nIUser doctorUser = authService.login(\"dr_smith\", \"password123\");\n// Expected decoration chain: BaseUser → DoctorRole\n// Doctor permissions available:\nassertTrue(doctorUser.hasPermission(\"can_access_appointments\"));\nassertTrue(doctorUser.hasPermission(\"can_mark_appointment_done\"));\nassertTrue(doctorUser.hasPermission(\"can_add_appointment_notes\"));\nassertTrue(doctorUser.hasPermission(\"can_access_patients\"));\n// Doctor permissions NOT available:\nassertFalse(doctorUser.hasPermission(\"can_book_appointment\"));\nassertFalse(doctorUser.hasPermission(\"can_delete_patient\"));\nassertFalse(doctorUser.hasPermission(\"can_manage_staff\"));\nassertFalse(doctorUser.hasPermission(\"can_access_billing\"));\n// Doctor-specific data available:\nassertNotNull(doctorUser.getDoctorId()); // \"D001\"\nassertEquals(\"Doctor\", doctorUser.getRole());\nassertEquals(\"dr_smith\", doctorUser.getUsername());","62-scenario-2-nurse-login-and-permissions#6.2 Scenario 2: Nurse Login and Permissions":"// Login process for a nurse\nIUser nurseUser = authService.login(\"nurse_jane\", \"securepass\");\n// Expected decoration chain: BaseUser → NurseRole\n// Nurse permissions available:\nassertTrue(nurseUser.hasPermission(\"can_access_patients\"));\nassertTrue(nurseUser.hasPermission(\"can_access_appointments\"));\nassertTrue(nurseUser.hasPermission(\"can_book_appointment\"));\nassertTrue(nurseUser.hasPermission(\"can_cancel_appointment\"));\nassertTrue(nurseUser.hasPermission(\"can_update_appointment_reason\"));\nassertTrue(nurseUser.hasPermission(\"can_generate_reports\"));\n// Nurse permissions NOT available:\nassertFalse(nurseUser.hasPermission(\"can_mark_appointment_done\"));\nassertFalse(nurseUser.hasPermission(\"can_add_appointment_notes\"));\nassertFalse(nurseUser.hasPermission(\"can_delete_patient\"));\nassertFalse(nurseUser.hasPermission(\"can_access_billing\"));\n// Nurse-specific data:\nassertNull(nurseUser.getDoctorId()); // Nurses don't have doctor IDs\nassertEquals(\"Nurse\", nurseUser.getRole());\nassertEquals(\"nurse_jane\", nurseUser.getUsername());","63-scenario-3-admin-login-and-permissions#6.3 Scenario 3: Admin Login and Permissions":"// Login process for an admin\nIUser adminUser = authService.login(\"admin_bob\", \"adminpass\");\n// Expected decoration chain: BaseUser → AdminRole\n// Admin has ALL permissions:\nassertTrue(adminUser.hasPermission(\"can_access_appointments\"));\nassertTrue(adminUser.hasPermission(\"can_delete_patient\"));\nassertTrue(adminUser.hasPermission(\"can_manage_staff\"));\nassertTrue(adminUser.hasPermission(\"can_manage_doctors\"));\nassertTrue(adminUser.hasPermission(\"can_access_billing\"));\nassertTrue(adminUser.hasPermission(\"can_process_payments\"));\nassertTrue(adminUser.hasPermission(\"any_permission_string\"));\n// Admin-specific data:\nassertNull(adminUser.getDoctorId()); // Admins typically don't have doctor IDs\nassertEquals(\"Admin\", adminUser.getRole());\nassertEquals(\"admin_bob\", adminUser.getUsername());","64-scenario-4-permission-based-ui-updates#6.4 Scenario 4: Permission-Based UI Updates":"// Example of how UI elements are dynamically enabled/disabled\npublic class AppointmentController {\n    private void updateUIBasedOnPermissions() {\n        // Appointment booking - available to nurses and admins\n        view.bookAppointmentButton.setEnabled(\n            currentUser.hasPermission(\"can_book_appointment\")\n        );\n        // Doctor management - admin only\n        boolean canManageDoctors = currentUser.hasPermission(\"can_manage_doctors\");\n        view.addDoctorButton.setEnabled(canManageDoctors);\n        view.deleteDoctorButton.setEnabled(canManageDoctors);\n        // Doctor-specific view - available if user is a doctor OR has appointment access\n        view.viewScheduleButton.setEnabled(\n            currentUser.getDoctorId() != null ||\n            currentUser.hasPermission(\"can_access_appointments\")\n        );\n        // Different buttons for different roles on same appointment\n        if (selectedAppointment != null) {\n            boolean isDoctor = currentUser.getDoctorId() != null;\n            boolean isOwner = isDoctor &&\n                             currentUser.getDoctorId().equals(selectedAppointment.getDoctorId());\n            // Only doctors can update prescriptions on their own appointments\n            view.updatePrescriptionButton.setEnabled(\n                currentUser.hasPermission(\"can_add_appointment_notes\") &&\n                isOwner\n            );\n            // Only nurses/admins can update appointment reasons\n            view.updateReasonButton.setEnabled(\n                currentUser.hasPermission(\"can_update_appointment_reason\") &&\n                !isDoctor\n            );\n        }\n    }\n}","7-benefits--trade-offs#7. Benefits & Trade-offs":"","71-decorator-pattern-benefits#7.1 Decorator Pattern Benefits":"Flexible Permission Composition\nMultiple roles can be combined by stacking decorators\nNew roles can be added without modifying existing code\nPermission logic is encapsulated within specific role classes\nEasy to add temporary or special permissions\nSingle Responsibility Principle\nEach role decorator focuses on specific permission sets\nBase user handles core user data without permission logic\nClear separation between user identification and authorization\nEasy to modify individual role permissions\nOpen/Closed Principle\nSystem is open for extension (new roles) but closed for modification\nExisting role implementations remain unchanged when adding new roles\nPermission changes localized to specific role classes\nEasy to test individual permission sets\nRuntime Flexibility\nUser permissions can be modified during session if needed\nMultiple decorators can be applied to same user\nContext-aware permission checking supported\nDynamic role assignment possible","72-healthcare-domain-specific-benefits#7.2 Healthcare Domain Specific Benefits":"Regulatory Compliance\nClear audit trail of permission usage\nRole-based access control required by healthcare regulations\nSeparation of clinical and administrative permissions\nEasy to demonstrate compliance with access control requirements\nPatient Safety\nPrevents unauthorized access to patient data\nEnsures only qualified staff can perform medical procedures\nClear boundaries between different healthcare roles\nReduces risk of data breaches or unauthorized modifications\nOperational Efficiency\nStaff can only access functions relevant to their role\nReduced UI complexity by hiding irrelevant features\nClear workflow separation between different staff types\nMinimizes training requirements for role-specific features\nScalability\nEasy to add new healthcare roles (e.g., Pharmacist, Lab Technician)\nSupports complex organizational hierarchies\nCan handle temporary role assignments or coverage situations\nAdapts to different healthcare facility structures","73-trade-offs-and-considerations#7.3 Trade-offs and Considerations":"Complexity Management\nMultiple layers of decoration can make debugging difficult\nPermission checking logic distributed across multiple classes\nNeed careful design to avoid permission conflicts\nStack of decorators can impact performance\nTesting Complexity\nNeed to test all possible permission combinations\nIntegration testing required for role interactions\nMock objects needed for decorator chains\nPermission edge cases can be difficult to identify\nPerformance Considerations\nMethod call overhead through decorator chain\nPermission checking happens frequently throughout application\nMemory overhead for decorator objects\nMay need caching for frequently checked permissions\nMaintenance Overhead\nPermission changes may require updates across multiple classes\nNeed to maintain consistency between roles\nDocumentation critical for understanding permission matrix\nVersion control of permission changes becomes important","8-testing--validation#8. Testing & Validation":"","81-unit-testing-role-decorators#8.1 Unit Testing Role Decorators":"@Test\npublic void testDoctorRolePermissions() {\n    // Arrange\n    BaseUser baseUser = new BaseUser(\"dr_test\", \"Doctor\", \"D001\");\n    DoctorRole doctorRole = new DoctorRole(baseUser);\n    // Act & Assert - Doctor permissions\n    assertTrue(doctorRole.hasPermission(\"can_access_appointments\"));\n    assertTrue(doctorRole.hasPermission(\"can_mark_appointment_done\"));\n    assertTrue(doctorRole.hasPermission(\"can_add_appointment_notes\"));\n    assertTrue(doctorRole.hasPermission(\"can_access_patients\"));\n    // Act & Assert - Non-doctor permissions\n    assertFalse(doctorRole.hasPermission(\"can_book_appointment\"));\n    assertFalse(doctorRole.hasPermission(\"can_delete_patient\"));\n    assertFalse(doctorRole.hasPermission(\"can_manage_staff\"));\n    // Act & Assert - Base user properties preserved\n    assertEquals(\"dr_test\", doctorRole.getUsername());\n    assertEquals(\"Doctor\", doctorRole.getRole());\n    assertEquals(\"D001\", doctorRole.getDoctorId());\n}\n@Test\npublic void testNurseRolePermissions() {\n    // Arrange\n    BaseUser baseUser = new BaseUser(\"nurse_test\", \"Nurse\", null);\n    NurseRole nurseRole = new NurseRole(baseUser);\n    // Act & Assert - Nurse permissions\n    assertTrue(nurseRole.hasPermission(\"can_access_patients\"));\n    assertTrue(nurseRole.hasPermission(\"can_book_appointment\"));\n    assertTrue(nurseRole.hasPermission(\"can_cancel_appointment\"));\n    assertTrue(nurseRole.hasPermission(\"can_update_appointment_reason\"));\n    // Act & Assert - Restricted permissions\n    assertFalse(nurseRole.hasPermission(\"can_mark_appointment_done\"));\n    assertFalse(nurseRole.hasPermission(\"can_add_appointment_notes\"));\n    assertFalse(nurseRole.hasPermission(\"can_delete_patient\"));\n    assertFalse(nurseRole.hasPermission(\"can_access_billing\"));\n}\n@Test\npublic void testAdminRolePermissions() {\n    // Arrange\n    BaseUser baseUser = new BaseUser(\"admin_test\", \"Admin\", null);\n    AdminRole adminRole = new AdminRole(baseUser);\n    // Act & Assert - Admin has all permissions\n    assertTrue(adminRole.hasPermission(\"can_access_appointments\"));\n    assertTrue(adminRole.hasPermission(\"can_delete_patient\"));\n    assertTrue(adminRole.hasPermission(\"can_manage_staff\"));\n    assertTrue(adminRole.hasPermission(\"can_access_billing\"));\n    assertTrue(adminRole.hasPermission(\"any_permission\"));\n    assertTrue(adminRole.hasPermission(\"non_existent_permission\"));\n}","82-integration-testing-with-controllers#8.2 Integration Testing with Controllers":"@Test\npublic void testAppointmentControllerWithDoctorUser() {\n    // Arrange\n    IUser doctorUser = new DoctorRole(new BaseUser(\"dr_test\", \"Doctor\", \"D001\"));\n    AppointmentController controller = new AppointmentController(view, mainFrame, doctorUser);\n    // Act\n    controller.applyPermissions();\n    // Assert - Doctor-specific UI states\n    assertTrue(view.viewScheduleButton.isEnabled()); // Doctor can view their schedule\n    assertFalse(view.bookAppointmentButton.isEnabled()); // Doctor cannot book appointments\n    assertTrue(view.viewAllAppointmentsButton.isEnabled()); // Doctor can view appointments\n    assertFalse(view.addDoctorButton.isEnabled()); // Doctor cannot manage other doctors\n}\n@Test\npublic void testPatientControllerWithNurseUser() {\n    // Arrange\n    IUser nurseUser = new NurseRole(new BaseUser(\"nurse_test\", \"Nurse\", null));\n    PatientController controller = new PatientController(view, mainFrame, nurseUser);\n    // Act\n    controller.initController();\n    // Assert - Nurse-specific UI states\n    assertFalse(view.viewAllButton.isEnabled()); // Nurse cannot view all patients\n    // Nurse can access individual patients but not perform bulk operations\n}\n@Test\npublic void testStaffControllerWithAdminUser() {\n    // Arrange\n    IUser adminUser = new AdminRole(new BaseUser(\"admin_test\", \"Admin\", null));\n    StaffController controller = new StaffController(view, mainFrame, adminUser);\n    // Act\n    controller.applyPermissions();\n    // Assert - Admin has full access\n    assertTrue(view.addButton.isEnabled());\n    assertTrue(view.updateButton.isEnabled() || !isStaffSelected());\n    assertTrue(view.deleteButton.isEnabled() || !isStaffSelected());\n    assertTrue(view.refreshStaffButton.isEnabled());\n}","83-security-testing#8.3 Security Testing":"@Test\npublic void testUnauthorizedAccess() {\n    // Test that users without permissions cannot access restricted functions\n    IUser nurseUser = new NurseRole(new BaseUser(\"nurse_test\", \"Nurse\", null));\n    // Attempt unauthorized operations\n    AppointmentController controller = new AppointmentController(view, mainFrame, nurseUser);\n    // These should fail with appropriate error messages\n    assertThrows(SecurityException.class, () -> {\n        controller.deleteDoctor(); // Nurse cannot delete doctors\n    });\n    PatientController patientController = new PatientController(view, mainFrame, nurseUser);\n    assertThrows(SecurityException.class, () -> {\n        patientController.deletePatient(); // Nurse cannot delete patients\n    });\n}\n@Test\npublic void testPermissionEscalation() {\n    // Test that users cannot escalate their permissions\n    BaseUser baseUser = new BaseUser(\"test_user\", \"Unknown\", null);\n    // Base user should have no permissions\n    assertFalse(baseUser.hasPermission(\"can_access_patients\"));\n    assertFalse(baseUser.hasPermission(\"can_delete_patient\"));\n    assertFalse(baseUser.hasPermission(\"admin_permission\"));\n    // Adding unknown role should not grant permissions\n    // (This would be handled by the factory method returning base user)\n}","84-performance-testing#8.4 Performance Testing":"@Test\npublic void testPermissionCheckingPerformance() {\n    // Arrange\n    IUser doctorUser = new DoctorRole(new BaseUser(\"dr_test\", \"Doctor\", \"D001\"));\n    int iterations = 100000;\n    // Act\n    long startTime = System.nanoTime();\n    for (int i = 0; i < iterations; i++) {\n        doctorUser.hasPermission(\"can_access_appointments\");\n        doctorUser.hasPermission(\"can_delete_patient\");\n        doctorUser.hasPermission(\"can_manage_staff\");\n    }\n    long endTime = System.nanoTime();\n    // Assert\n    long durationMs = (endTime - startTime) / 1_000_000;\n    assertTrue(\"Permission checking should be fast\", durationMs < 100);\n    System.out.println(String.format(\"Permission checking: %d iterations in %d ms\",\n                                    iterations * 3, durationMs));\n}","conclusion#Conclusion":"The Decorator pattern implementation for medical staff roles and permissions demonstrates a sophisticated approach to access control in healthcare systems. The pattern successfully addresses the complex requirements of role-based permissions while maintaining flexibility and extensibility.","key-achievements#Key Achievements":"Flexible Role Management: Successfully implements a dynamic permission system that can adapt to different healthcare organizational structures\nSecurity Compliance: Provides robust access control mechanisms essential for healthcare data protection and regulatory compliance\nExtensible Architecture: Easy addition of new roles without modifying existing code, supporting evolving healthcare requirements\nClear Separation of Concerns: Clean separation between user identification, role assignment, and permission checking\nContext-Aware Permissions: Supports complex permission scenarios where access depends on ownership, status, or other contextual factors","real-world-healthcare-impact#Real-World Healthcare Impact":"The Decorator pattern proves particularly valuable in healthcare contexts where:\nRegulatory Compliance requires strict role-based access control with audit capabilities\nPatient Safety depends on ensuring only qualified staff can access or modify sensitive medical data\nOperational Efficiency benefits from role-appropriate UI and functionality exposure\nStaff Management needs flexible permission assignment for different healthcare roles and temporary assignments\nSystem Integration requires clear permission boundaries for interfacing with external healthcare systems","pattern-benefits-realized#Pattern Benefits Realized":"The implementation successfully demonstrates how the Decorator pattern can:\nEnable dynamic composition of permissions without complex inheritance hierarchies\nSupport fine-grained access control with role-specific and context-aware permissions\nFacilitate easy testing and validation of individual role permissions\nProvide clear audit trails for security and compliance requirements\nMaintain clean separation between user authentication and authorization concerns\nThe medical staff permission system provides a robust foundation for secure healthcare application access while maintaining the flexibility needed for complex healthcare organizational structures and evolving regulatory requirements.Document Status: Part D CompleteNext: Part E: Generating Medical Reports - Visitor Pattern"}},"/medical-reports":{"title":"Medical Reports Generation","data":{"":"Document: Part E AnalysisPattern: Visitor PatternModule: Medical Reports Generation SystemAuthor: Ishara Lakshitha","table-of-contents#Table of Contents":"","1-overview--problem-statement#1. Overview & Problem Statement":"","healthcare-domain-problems-addressed#Healthcare Domain Problems Addressed":"Problem 1: Diverse Reporting Requirements\nHealthcare systems need multiple types of reports for different stakeholders\nFinancial reports for billing departments and insurance companies\nClinical reports for medical staff and patient care coordination\nAdministrative reports for management and regulatory compliance\nPatient-specific reports for individualized care planning\nProblem 2: Complex Data Aggregation\nReports must combine data from multiple domain objects (Patients, Appointments, Bills)\nDifferent report types require different data processing algorithms\nNeed to maintain data consistency across different report formats\nComplex calculations involving financial, clinical, and operational metrics\nProblem 3: Extensible Report Framework\nNew report types frequently required for changing business needs\nRegulatory requirements often demand new reporting formats\nMust support custom report generation without modifying existing domain objects\nNeed to separate report generation logic from core business objects","solution-approach#Solution Approach":"The Visitor Pattern provides a flexible reporting framework where:\nDomain Objects (PatientRecord, Appointment, MedicalBill) implement Visitable interface\nReport Visitors encapsulate specific report generation algorithms\nData Processing is separated from domain object structure\nExtensibility allows adding new report types without modifying existing code","2-visitor-pattern-implementation#2. Visitor Pattern Implementation":"","21-pattern-participants#2.1 Pattern Participants":"","visitor-interface#Visitor Interface":"/**\n * The Visitor interface. It declares a set of visiting methods for each\n * concrete Visitable element.\n */\npublic interface ReportVisitor {\n    void visit(PatientRecord patient);\n    void visit(Appointment appointment);\n    void visit(MedicalBill bill);\n    // Method to retrieve the final generated report\n    String getReport();\n}","element-interface#Element Interface":"/**\n * Defines the accept method that allows a visitor to perform an operation on an object.\n * This is the \"Element\" interface in the Visitor pattern.\n */\npublic interface Visitable {\n    void accept(ReportVisitor visitor);\n}","concrete-elements#Concrete Elements":"PatientRecord Implementation\npublic class PatientRecord implements Visitable {\n    private String patientId;\n    private String name;\n    private String medicalHistory;\n    private String treatmentPlans;\n    private InsurancePlan insurancePlan;\n    @Override\n    public void accept(ReportVisitor visitor) {\n        visitor.visit(this);\n    }\n    // Getters and other methods...\n}\nAppointment Implementation\npublic class Appointment implements Visitable {\n    private int appointmentId;\n    private String patientId;\n    private String doctorId;\n    private LocalDateTime appointmentDateTime;\n    private String reason;\n    private String status;\n    private String doctorNotes;\n    @Override\n    public void accept(ReportVisitor visitor) {\n        visitor.visit(this);\n    }\n    // Business methods and validation...\n}\nMedicalBill Implementation\npublic class MedicalBill implements Visitable {\n    private int billId;\n    private String patientId;\n    private String serviceDescription;\n    private double amount;\n    private double amountPaid;\n    private double insurancePaidAmount;\n    private String status;\n    @Override\n    public void accept(ReportVisitor visitor) {\n        visitor.visit(this);\n    }\n    // Financial calculation methods...\n}","22-concrete-visitor-implementations#2.2 Concrete Visitor Implementations":"","patient-summary-report-visitor#Patient Summary Report Visitor":"/**\n * Patient Summary Report Visitor - Fixed to match actual database schema\n * Provides comprehensive overview of patient's healthcare and financial information\n */\npublic class PatientSummaryReportVisitor implements ReportVisitor {\n    private final StringBuilder reportContent = new StringBuilder();\n    private final List<Appointment> appointments = new ArrayList<>();\n    private final List<MedicalBill> bills = new ArrayList<>();\n    private final Map<String, Integer> serviceCount = new HashMap<>();\n    private final Map<String, Integer> doctorVisits = new HashMap<>();\n    private final DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\");\n    private PatientRecord currentPatient;\n    private double totalBilled = 0;\n    private double totalCollected = 0;\n    private double totalOutstanding = 0;\n    @Override\n    public void visit(PatientRecord patient) {\n        this.currentPatient = patient;\n        reportContent.append(repeatString(\"=\", 90)).append(\"\\\\n\");\n        reportContent.append(\"    COMPREHENSIVE PATIENT SUMMARY REPORT\\\\n\");\n        reportContent.append(repeatString(\"=\", 90)).append(\"\\\\n\");\n        reportContent.append(\"Patient: \").append(patient.getName())\n                .append(\" (ID: \").append(patient.getPatientId()).append(\")\\\\n\");\n        reportContent.append(repeatString(\"=\", 90)).append(\"\\\\n\\\\n\");\n    }\n    @Override\n    public void visit(Appointment appointment) {\n        appointments.add(appointment);\n        // Track doctor visits\n        String doctorId = appointment.getDoctorId();\n        doctorVisits.put(doctorId, doctorVisits.getOrDefault(doctorId, 0) + 1);\n    }\n    @Override\n    public void visit(MedicalBill bill) {\n        bills.add(bill);\n        totalBilled += bill.getAmount();\n        totalCollected += bill.getTotalCollected();\n        totalOutstanding += bill.getRemainingBalance();\n        // Track service usage\n        String service = bill.getServiceDescription();\n        serviceCount.put(service, serviceCount.getOrDefault(service, 0) + 1);\n    }\n    @Override\n    public String getReport() {\n        generatePatientInformation();\n        generateHealthcareSummary();\n        generateFinancialSummary();\n        generateRecentActivity();\n        generateServiceUtilization();\n        generateDoctorRelationships();\n        generateHealthIndicators();\n        generateActionItems();\n        return reportContent.toString();\n    }\n    private void generatePatientInformation() {\n        reportContent.append(\"PATIENT INFORMATION\\\\n\");\n        reportContent.append(repeatString(\"-\", 50)).append(\"\\\\n\");\n        reportContent.append(\"Name: \").append(currentPatient.getName()).append(\"\\\\n\");\n        reportContent.append(\"Patient ID: \").append(currentPatient.getPatientId()).append(\"\\\\n\");\n        reportContent.append(\"Medical History: \").append(currentPatient.getMedicalHistory()).append(\"\\\\n\");\n        reportContent.append(\"Treatment Plans: \").append(currentPatient.getTreatmentPlans()).append(\"\\\\n\");\n        if (currentPatient.getInsurancePlan() != null) {\n            reportContent.append(\"Insurance: \").append(currentPatient.getInsurancePlan().getPlanName())\n                    .append(\" (\").append(currentPatient.getInsurancePlan().getCoveragePercent()).append(\"% coverage)\\\\n\");\n        }\n        reportContent.append(\"\\\\n\");\n    }\n    private void generateHealthcareSummary() {\n        reportContent.append(\"HEALTHCARE SUMMARY\\\\n\");\n        reportContent.append(repeatString(\"-\", 50)).append(\"\\\\n\");\n        reportContent.append(\"Total Appointments: \").append(appointments.size()).append(\"\\\\n\");\n        reportContent.append(\"Total Services: \").append(bills.size()).append(\"\\\\n\");\n        reportContent.append(\"Unique Doctors Seen: \").append(doctorVisits.size()).append(\"\\\\n\");\n        // Healthcare engagement indicator\n        if (appointments.size() > 20) {\n            reportContent.append(\"Healthcare Engagement: 🔴 High utilization\\\\n\");\n        } else if (appointments.size() > 10) {\n            reportContent.append(\"Healthcare Engagement: 🟡 Regular patient\\\\n\");\n        } else if (appointments.size() > 3) {\n            reportContent.append(\"Healthcare Engagement: 🟢 Moderate usage\\\\n\");\n        } else {\n            reportContent.append(\"Healthcare Engagement: ⚪ Limited interaction\\\\n\");\n        }\n        reportContent.append(\"\\\\n\");\n    }\n    private void generateFinancialSummary() {\n        reportContent.append(\"FINANCIAL SUMMARY\\\\n\");\n        reportContent.append(repeatString(\"-\", 50)).append(\"\\\\n\");\n        reportContent.append(String.format(\"Total Billed: $%.2f\\\\n\", totalBilled));\n        reportContent.append(String.format(\"Total Collected: $%.2f\\\\n\", totalCollected));\n        reportContent.append(String.format(\"Outstanding Balance: $%.2f\\\\n\", totalOutstanding));\n        if (totalBilled > 0) {\n            double collectionRate = (totalCollected / totalBilled) * 100;\n            reportContent.append(String.format(\"Collection Rate: %.1f%%\\\\n\", collectionRate));\n        }\n        reportContent.append(\"\\\\n\");\n    }\n    // Additional helper methods for report generation...\n    private String repeatString(String str, int count) {\n        return str.repeat(Math.max(0, count));\n    }\n}","financial-report-visitor#Financial Report Visitor":"/**\n * Enhanced Financial Report Visitor - Fixed to match actual DB schema and MedicalBill class\n */\npublic class FinancialReportVisitor implements ReportVisitor {\n    private final StringBuilder reportContent = new StringBuilder();\n    private final List<MedicalBill> bills = new ArrayList<>();\n    private final Map<String, Double> serviceRevenue = new HashMap<>();\n    private final DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\");\n    private String patientName = \"\";\n    private String patientId = \"\";\n    private double totalBilled = 0;\n    private double totalPatientPaid = 0;\n    private double totalInsurancePaid = 0;\n    private double totalOutstanding = 0;\n    @Override\n    public void visit(PatientRecord patient) {\n        this.patientName = patient.getName();\n        this.patientId = patient.getPatientId();\n        reportContent.append(repeatString(\"=\", 80)).append(\"\\\\n\");\n        reportContent.append(\"    INDIVIDUAL PATIENT FINANCIAL SUMMARY\\\\n\");\n        reportContent.append(repeatString(\"=\", 80)).append(\"\\\\n\");\n        reportContent.append(\"Patient: \").append(patient.getName())\n                .append(\" (ID: \").append(patient.getPatientId()).append(\")\\\\n\");\n        reportContent.append(\"Generated: \").append(LocalDate.now().format(dateFormatter)).append(\"\\\\n\");\n        reportContent.append(repeatString(\"=\", 80)).append(\"\\\\n\\\\n\");\n    }\n    @Override\n    public void visit(Appointment appointment) {\n        // Could track appointment revenue correlation if needed\n    }\n    @Override\n    public void visit(MedicalBill bill) {\n        bills.add(bill);\n        totalBilled += bill.getAmount();\n        totalPatientPaid += bill.getAmountPaid();\n        totalInsurancePaid += bill.getInsurancePaidAmount();\n        totalOutstanding += bill.getRemainingBalance();\n        // Track revenue by service type\n        String service = bill.getServiceDescription();\n        serviceRevenue.put(service, serviceRevenue.getOrDefault(service, 0.0) + bill.getAmount());\n    }\n    @Override\n    public String getReport() {\n        generateFinancialOverview();\n        generatePaymentBreakdown();\n        generateServiceRevenue();\n        generatePaymentStatus();\n        generateRecommendations();\n        return reportContent.toString();\n    }\n    private void generateFinancialOverview() {\n        reportContent.append(\"FINANCIAL OVERVIEW\\\\n\");\n        reportContent.append(repeatString(\"-\", 50)).append(\"\\\\n\");\n        reportContent.append(String.format(\"Total Amount Billed: $%,.2f\\\\n\", totalBilled));\n        reportContent.append(String.format(\"Patient Payments: $%,.2f\\\\n\", totalPatientPaid));\n        reportContent.append(String.format(\"Insurance Payments: $%,.2f\\\\n\", totalInsurancePaid));\n        reportContent.append(String.format(\"Total Collected: $%,.2f\\\\n\", totalPatientPaid + totalInsurancePaid));\n        reportContent.append(String.format(\"Outstanding Balance: $%,.2f\\\\n\", totalOutstanding));\n        reportContent.append(\"\\\\n\");\n    }\n    // Additional financial analysis methods...\n}","service-utilization-report-visitor#Service Utilization Report Visitor":"/**\n * Patient Service Utilization Visitor - Fixed to match actual database schema\n * Analyzes patient's service usage patterns, appointments, and healthcare utilization\n */\npublic class PatientServiceUtilizationVisitor implements ReportVisitor {\n    private final StringBuilder reportContent = new StringBuilder();\n    private final Map<String, ServiceUtilization> serviceUsage = new HashMap<>();\n    private final Map<String, DoctorUtilization> doctorVisits = new HashMap<>();\n    private final List<Appointment> appointments = new ArrayList<>();\n    private final List<MedicalBill> bills = new ArrayList<>();\n    private String patientName = \"\";\n    private String patientId = \"\";\n    private double totalSpent = 0;\n    private double totalBilled = 0;\n    private int totalServices = 0;\n    @Override\n    public void visit(PatientRecord patient) {\n        this.patientName = patient.getName();\n        this.patientId = patient.getPatientId();\n        reportContent.append(repeatString(\"=\", 90)).append(\"\\\\n\");\n        reportContent.append(\"    PATIENT SERVICE UTILIZATION REPORT\\\\n\");\n        reportContent.append(repeatString(\"=\", 90)).append(\"\\\\n\\\\n\");\n    }\n    @Override\n    public void visit(Appointment appointment) {\n        // Only process appointments for the current patient\n        if (appointment.getPatientId().equals(this.patientId)) {\n            appointments.add(appointment);\n            // Track doctor utilization\n            String doctorId = appointment.getDoctorId();\n            DoctorUtilization doctorUtil = doctorVisits.getOrDefault(doctorId,\n                    new DoctorUtilization(doctorId));\n            doctorUtil.addAppointment(appointment);\n            doctorVisits.put(doctorId, doctorUtil);\n        }\n    }\n    @Override\n    public void visit(MedicalBill bill) {\n        // Only process bills for the current patient\n        if (bill.getPatientId().equals(this.patientId)) {\n            bills.add(bill);\n            totalServices++;\n            totalBilled += bill.getAmount();\n            totalSpent += bill.getTotalCollected();\n            String serviceName = bill.getServiceDescription();\n            ServiceUtilization utilization = serviceUsage.getOrDefault(serviceName,\n                    new ServiceUtilization(serviceName));\n            utilization.addService(bill);\n            serviceUsage.put(serviceName, utilization);\n        }\n    }\n    @Override\n    public String getReport() {\n        generateUtilizationSummary();\n        generateAppointmentAnalysis();\n        generateServiceBreakdown();\n        generateDoctorUtilization();\n        generateUtilizationPatterns();\n        generateHealthcareValue();\n        generateRecommendations();\n        return reportContent.toString();\n    }\n    // Inner classes for data aggregation\n    private static class ServiceUtilization {\n        private final String serviceName;\n        private int usageCount = 0;\n        private double totalBilled = 0;\n        private double totalPaid = 0;\n        private double totalOutstanding = 0;\n        public ServiceUtilization(String serviceName) {\n            this.serviceName = serviceName;\n        }\n        public void addService(MedicalBill bill) {\n            usageCount++;\n            totalBilled += bill.getAmount();\n            totalPaid += bill.getTotalCollected();\n            totalOutstanding += bill.getRemainingBalance();\n        }\n        // Getters...\n    }\n    private static class DoctorUtilization {\n        private final String doctorId;\n        private final List<Appointment> appointments = new ArrayList<>();\n        private final Map<String, Integer> reasonCount = new HashMap<>();\n        private final Map<String, Integer> statusCount = new HashMap<>();\n        public DoctorUtilization(String doctorId) {\n            this.doctorId = doctorId;\n        }\n        public void addAppointment(Appointment appointment) {\n            appointments.add(appointment);\n            String reason = appointment.getReason();\n            if (reason != null && !reason.trim().isEmpty()) {\n                reasonCount.put(reason, reasonCount.getOrDefault(reason, 0) + 1);\n            }\n            String status = appointment.getStatus();\n            statusCount.put(status, statusCount.getOrDefault(status, 0) + 1);\n        }\n        // Getters and analysis methods...\n    }\n}","3-uml-class-diagrams#3. UML Class Diagrams":"","30-comprehensive-diagram#3.0 Comprehensive Diagram":"(You can find the High Res images in the Github Project Repo)","31-visitor-pattern-structure#3.1 Visitor Pattern Structure":"┌─────────────────────────────────────┐\n│          <<interface>>              │\n│        ReportVisitor                │\n├─────────────────────────────────────┤\n│ + visit(patient: PatientRecord)     │\n│ + visit(appointment: Appointment)   │\n│ + visit(bill: MedicalBill)          │\n│ + getReport(): String               │\n└─────────────────────────────────────┘\n                    ▲\n        ┌───────────┼───────────┐\n        │           │           │\n┌───────────────┐ ┌─────────────┐ ┌──────────────────┐\n│PatientSummary │ │Financial    │ │ServiceUtilization│\n│ReportVisitor  │ │ReportVisitor│ │Visitor           │\n├───────────────┤ ├─────────────┤ ├──────────────────┤\n│- reportContent│ │- bills: List│ │- serviceUsage    │\n│- appointments │ │- totalBilled│ │- doctorVisits    │\n│- bills: List  │ │- totalPaid  │ │- appointments    │\n│- serviceCount │ └─────────────┘ └──────────────────┘\n│- doctorVisits │\n└───────────────┘\n┌─────────────────────────────────────┐\n│          <<interface>>              │\n│           Visitable                 │\n├─────────────────────────────────────┤\n│ + accept(visitor: ReportVisitor)    │\n└─────────────────────────────────────┘\n                    ▲\n        ┌───────────┼───────────┐\n        │           │           │\n┌───────────────┐ ┌─────────────┐ ┌──────────────┐\n│PatientRecord  │ │Appointment  │ │MedicalBill   │\n├───────────────┤ ├─────────────┤ ├──────────────┤\n│- patientId    │ │- appointmentId│ │- billId      │\n│- name         │ │- patientId  │ │- patientId   │\n│- medicalHist. │ │- doctorId   │ │- amount      │\n│- insurance    │ │- dateTime   │ │- amountPaid  │\n├───────────────┤ │- reason     │ │- status      │\n│+ accept()     │ │- status     │ ├──────────────┤\n└───────────────┘ ├─────────────┤ │+ accept()    │\n                  │+ accept()   │ │+ getTotalColl│\n                  └─────────────┘ │  ected()     │\n                                  └──────────────┘","32-report-generation-flow#3.2 Report Generation Flow":"ReportController\n        │\n        ▼\n    generateReport(visitor)\n        │\n        ├─→ patient.accept(visitor) ─→ visitor.visit(patient)\n        │                                      │\n        ├─→ appointments.forEach(apt →         │\n        │     apt.accept(visitor)) ─→ visitor.visit(appointment)\n        │                                      │\n        └─→ bills.forEach(bill →               │\n              bill.accept(visitor)) ─→ visitor.visit(bill)\n                                               │\n                                               ▼\n                                     visitor.getReport()\n                                               │\n                                               ▼\n                                        Generated Report","4-detailed-code-analysis#4. Detailed Code Analysis":"","41-report-controller-integration#4.1 Report Controller Integration":"/**\n * ReportController manages report generation workflow\n * Demonstrates how the Visitor pattern integrates with the controller layer\n */\npublic class ReportController {\n    private final ReportPanel view;\n    private final BillingDAO billingDAO;\n    private final SchedulingDAO schedulingDAO;\n    private final PatientDAO patientDAO;\n    private final IUser currentUser;\n    private PatientRecord currentPatient;\n    private void generatePatientSpecificReport(ReportVisitor visitor) {\n        processPatientData(visitor);\n        processPatientAppointments(visitor);\n        processPatientBills(visitor);\n    }\n    private void processPatientData(ReportVisitor visitor) {\n        // Process patient data\n        currentPatient.accept(visitor);\n    }\n    private void processPatientAppointments(ReportVisitor visitor) {\n        // Get appointments for the patient\n        List<Appointment> appointments = schedulingDAO.getAppointmentsByPatientId(\n                currentPatient.getPatientId());\n        for (Appointment appointment : appointments) {\n            appointment.accept(visitor);\n        }\n    }\n    private void processPatientBills(ReportVisitor visitor) {\n        // Get bills for the patient within date range\n        List<MedicalBill> bills = getBillsForPatientWithFilters(currentPatient.getPatientId());\n        for (MedicalBill bill : bills) {\n            bill.accept(visitor);\n        }\n    }\n    private void generatePatientSummaryReport() {\n        if (currentPatient == null) {\n            showError(\"Please select a patient first.\");\n            return;\n        }\n        PatientSummaryReportVisitor visitor = new PatientSummaryReportVisitor();\n        generatePatientSpecificReport(visitor);\n        String report = visitor.getReport();\n        view.displayReport(report);\n        JOptionPane.showMessageDialog(view,\n            \"Patient Summary Report generated successfully!\",\n            \"Report Generated\", JOptionPane.INFORMATION_MESSAGE);\n    }\n    private void generateFinancialReport() {\n        if (currentPatient == null) {\n            showError(\"Please select a patient first.\");\n            return;\n        }\n        FinancialReportVisitor visitor = new FinancialReportVisitor();\n        generatePatientSpecificReport(visitor);\n        String report = visitor.getReport();\n        view.displayReport(report);\n        JOptionPane.showMessageDialog(view,\n            \"Financial Report generated successfully!\",\n            \"Report Generated\", JOptionPane.INFORMATION_MESSAGE);\n    }\n}","42-complex-data-aggregation-examples#4.2 Complex Data Aggregation Examples":"","patient-summary-report-data-processing#Patient Summary Report Data Processing":"public class PatientSummaryReportVisitor implements ReportVisitor {\n    @Override\n    public void visit(PatientRecord patient) {\n        this.currentPatient = patient;\n        // Initialize report header with patient information\n        generateReportHeader(patient);\n    }\n    @Override\n    public void visit(Appointment appointment) {\n        appointments.add(appointment);\n        // Track doctor-patient relationships\n        String doctorId = appointment.getDoctorId();\n        doctorVisits.put(doctorId, doctorVisits.getOrDefault(doctorId, 0) + 1);\n        // Analyze appointment patterns\n        analyzeAppointmentPatterns(appointment);\n    }\n    @Override\n    public void visit(MedicalBill bill) {\n        bills.add(bill);\n        // Financial aggregation\n        totalBilled += bill.getAmount();\n        totalCollected += bill.getTotalCollected();\n        totalOutstanding += bill.getRemainingBalance();\n        // Service utilization tracking\n        String service = bill.getServiceDescription();\n        serviceCount.put(service, serviceCount.getOrDefault(service, 0) + 1);\n        // Payment analysis\n        analyzePaymentPatterns(bill);\n    }\n    private void generateHealthIndicators() {\n        reportContent.append(\"HEALTH INDICATORS\\\\n\");\n        reportContent.append(repeatString(\"-\", 50)).append(\"\\\\n\");\n        // Service diversity analysis\n        if (serviceCount.size() > 10) {\n            reportContent.append(\"Service Diversity: 🔴 High - complex healthcare needs\\\\n\");\n        } else if (serviceCount.size() > 5) {\n            reportContent.append(\"Service Diversity: 🟡 Moderate - varied healthcare needs\\\\n\");\n        } else {\n            reportContent.append(\"Service Diversity: 🟢 Focused - specific healthcare needs\\\\n\");\n        }\n        // Appointment compliance calculation\n        long completedAppointments = appointments.stream()\n                .filter(apt -> \"Completed\".equalsIgnoreCase(apt.getStatus()) ||\n                              \"Scheduled\".equalsIgnoreCase(apt.getStatus()))\n                .count();\n        if (appointments.size() > 0) {\n            double complianceRate = (double) completedAppointments / appointments.size() * 100;\n            reportContent.append(String.format(\"Appointment Compliance: %.1f%%\", complianceRate));\n            if (complianceRate >= 90) {\n                reportContent.append(\" 🟢 Excellent\\\\n\");\n            } else if (complianceRate >= 75) {\n                reportContent.append(\" 🟡 Good\\\\n\");\n            } else {\n                reportContent.append(\" 🔴 Needs Improvement\\\\n\");\n            }\n        }\n    }\n}","service-utilization-analysis#Service Utilization Analysis":"public class PatientServiceUtilizationVisitor implements ReportVisitor {\n    @Override\n    public void visit(MedicalBill bill) {\n        if (bill.getPatientId().equals(this.patientId)) {\n            bills.add(bill);\n            totalServices++;\n            totalBilled += bill.getAmount();\n            totalSpent += bill.getTotalCollected();\n            // Track service utilization patterns\n            String serviceName = bill.getServiceDescription();\n            ServiceUtilization utilization = serviceUsage.getOrDefault(serviceName,\n                    new ServiceUtilization(serviceName));\n            utilization.addService(bill);\n            serviceUsage.put(serviceName, utilization);\n        }\n    }\n    private void generateServiceBreakdown() {\n        reportContent.append(\"SERVICE UTILIZATION BREAKDOWN\\\\n\");\n        reportContent.append(repeatString(\"-\", 60)).append(\"\\\\n\");\n        reportContent.append(String.format(\"%-25s %8s %10s %10s %12s\\\\n\",\n                \"Service\", \"Count\", \"Billed\", \"Paid\", \"Outstanding\"));\n        reportContent.append(repeatString(\"-\", 60)).append(\"\\\\n\");\n        serviceUsage.values().stream()\n                .sorted((a, b) -> Double.compare(b.getTotalBilled(), a.getTotalBilled()))\n                .forEach(service -> {\n                    reportContent.append(String.format(\"%-25s %8d $%9.2f $%9.2f $%11.2f\\\\n\",\n                            truncateString(service.getServiceName(), 25),\n                            service.getUsageCount(),\n                            service.getTotalBilled(),\n                            service.getTotalPaid(),\n                            service.getTotalOutstanding()));\n                });\n        reportContent.append(\"\\\\n\");\n    }\n    private void generateHealthcareValue() {\n        reportContent.append(\"HEALTHCARE VALUE ANALYSIS\\\\n\");\n        reportContent.append(repeatString(\"-\", 50)).append(\"\\\\n\");\n        // Value indicators\n        if (appointments.size() > 10 && serviceUsage.size() > 5) {\n            reportContent.append(\"🟢 High healthcare engagement\\\\n\");\n        } else if (appointments.size() > 5) {\n            reportContent.append(\"🟡 Regular healthcare usage\\\\n\");\n        } else {\n            reportContent.append(\"🔴 Low healthcare utilization\\\\n\");\n        }\n        // Cost efficiency analysis\n        double costPerAppointment = appointments.size() > 0 ? totalBilled / appointments.size() : 0;\n        if (costPerAppointment > 500) {\n            reportContent.append(\"Higher cost utilization pattern\\\\n\");\n        } else if (costPerAppointment > 200) {\n            reportContent.append(\"Moderate cost utilization pattern\\\\n\");\n        } else {\n            reportContent.append(\"Lower cost utilization pattern\\\\n\");\n        }\n    }\n}","43-multi-domain-data-correlation#4.3 Multi-Domain Data Correlation":"/**\n * Doctor Revenue Performance Visitor demonstrates complex multi-domain analysis\n * Correlates appointment data with billing information for performance metrics\n */\npublic class DoctorRevenuePerformanceVisitor implements ReportVisitor {\n    @Override\n    public void visit(Appointment appointment) {\n        String doctorId = appointment.getDoctorId();\n        DoctorPerformance performance = doctorPerformance.getOrDefault(doctorId,\n                new DoctorPerformance(doctorId));\n        performance.addAppointment(appointment);\n        doctorPerformance.put(doctorId, performance);\n        totalAppointments++;\n        // Create mapping for later bill correlation\n        appointmentToBillMapping.put(appointment.getPatientId() + \"_\" +\n                appointment.getAppointmentDateTime().toLocalDate(), doctorId);\n    }\n    @Override\n    public void visit(MedicalBill bill) {\n        totalBills++;\n        totalSystemRevenue += bill.getAmount();\n        totalSystemCollected += bill.getTotalCollected();\n        // Find associated doctor through appointment correlation\n        String doctorId = findDoctorForBill(bill.getPatientId());\n        if (doctorId != null) {\n            DoctorPerformance performance = doctorPerformance.get(doctorId);\n            if (performance != null) {\n                performance.addRevenueBill(bill);\n            }\n        } else {\n            // Handle unassigned bills\n            DoctorPerformance unassigned = doctorPerformance.getOrDefault(\"UNASSIGNED\",\n                    new DoctorPerformance(\"UNASSIGNED\"));\n            unassigned.addRevenueBill(bill);\n            doctorPerformance.put(\"UNASSIGNED\", unassigned);\n        }\n    }\n    private String findDoctorForBill(String patientId) {\n        // Logic to correlate bills with appointments based on patient and timing\n        return appointmentToBillMapping.entrySet().stream()\n                .filter(entry -> entry.getKey().startsWith(patientId))\n                .map(Map.Entry::getValue)\n                .findFirst()\n                .orElse(null);\n    }\n    // Enhanced DoctorPerformance class with comprehensive metrics\n    private static class DoctorPerformance {\n        private final String doctorId;\n        private final List<Appointment> appointments = new ArrayList<>();\n        private final List<MedicalBill> bills = new ArrayList<>();\n        private final Map<String, Integer> appointmentStatusBreakdown = new HashMap<>();\n        private double totalBilled = 0;\n        private double totalPatientPaid = 0;\n        private double totalInsurancePaid = 0;\n        private double totalCollected = 0;\n        private double totalOutstanding = 0;\n        public void addAppointment(Appointment appointment) {\n            appointments.add(appointment);\n            String status = appointment.getStatus();\n            appointmentStatusBreakdown.put(status,\n                    appointmentStatusBreakdown.getOrDefault(status, 0) + 1);\n        }\n        public void addRevenueBill(MedicalBill bill) {\n            bills.add(bill);\n            totalBilled += bill.getAmount();\n            totalPatientPaid += bill.getAmountPaid();\n            totalInsurancePaid += bill.getInsurancePaidAmount();\n            totalCollected = totalPatientPaid + totalInsurancePaid;\n            totalOutstanding += bill.getRemainingBalance();\n        }\n        // Performance calculation methods\n        public double getRevenuePerAppointment() {\n            return appointments.size() > 0 ? totalBilled / appointments.size() : 0;\n        }\n        public double getCollectionRate() {\n            return totalBilled > 0 ? (totalCollected / totalBilled) * 100 : 0;\n        }\n    }\n}","5-report-generation-workflows#5. Report Generation Workflows":"","51-patient-specific-report-generation#5.1 Patient-Specific Report Generation":"/**\n * Complete workflow for generating patient-specific reports\n */\npublic void generatePatientReport(String reportType, String patientId) {\n    // Step 1: Retrieve patient data\n    PatientRecord patient = patientDAO.getPatientById(patientId);\n    if (patient == null) {\n        throw new IllegalArgumentException(\"Patient not found: \" + patientId);\n    }\n    // Step 2: Create appropriate visitor\n    ReportVisitor visitor = createVisitor(reportType);\n    // Step 3: Process patient data\n    patient.accept(visitor);\n    // Step 4: Process related appointments\n    List<Appointment> appointments = schedulingDAO.getAppointmentsByPatientId(patientId);\n    appointments.forEach(appointment -> appointment.accept(visitor));\n    // Step 5: Process related bills\n    List<MedicalBill> bills = billingDAO.getBillsByPatientId(patientId);\n    bills.forEach(bill -> bill.accept(visitor));\n    // Step 6: Generate final report\n    String report = visitor.getReport();\n    // Step 7: Display or save report\n    displayReport(report, reportType);\n}\nprivate ReportVisitor createVisitor(String reportType) {\n    switch (reportType) {\n        case \"PATIENT_SUMMARY\":\n            return new PatientSummaryReportVisitor();\n        case \"FINANCIAL\":\n            return new FinancialReportVisitor();\n        case \"SERVICE_UTILIZATION\":\n            return new PatientServiceUtilizationVisitor();\n        case \"PAYMENT_HISTORY\":\n            return new PatientPaymentHistoryVisitor();\n        default:\n            throw new IllegalArgumentException(\"Unknown report type: \" + reportType);\n    }\n}","52-system-wide-report-generation#5.2 System-Wide Report Generation":"/**\n * Workflow for generating comprehensive system reports\n */\npublic void generateSystemWideReport(String reportType, LocalDate startDate, LocalDate endDate) {\n    ReportVisitor visitor = createSystemVisitor(reportType);\n    // Process all patients\n    List<PatientRecord> patients = patientDAO.getAllPatients();\n    patients.forEach(patient -> patient.accept(visitor));\n    // Process appointments within date range\n    List<Appointment> appointments = schedulingDAO.getAppointmentsByDateRange(startDate, endDate);\n    appointments.forEach(appointment -> appointment.accept(visitor));\n    // Process bills within date range\n    List<MedicalBill> bills = billingDAO.getBillsByDateRange(startDate, endDate);\n    bills.forEach(bill -> bill.accept(visitor));\n    // Generate comprehensive report\n    String report = visitor.getReport();\n    displayReport(report, reportType);\n}\nprivate ReportVisitor createSystemVisitor(String reportType) {\n    switch (reportType) {\n        case \"COMPREHENSIVE_FINANCIAL\":\n            return new ComprehensiveFinancialSummaryVisitor();\n        case \"DOCTOR_PERFORMANCE\":\n            return new DoctorRevenuePerformanceVisitor();\n        case \"SYSTEM_UTILIZATION\":\n            return new SystemUtilizationReportVisitor();\n        default:\n            throw new IllegalArgumentException(\"Unknown system report type: \" + reportType);\n    }\n}","53-conditional-report-processing#5.3 Conditional Report Processing":"/**\n * Advanced report generation with conditional processing\n */\npublic class ConditionalReportVisitor implements ReportVisitor {\n    private final Predicate<PatientRecord> patientFilter;\n    private final Predicate<Appointment> appointmentFilter;\n    private final Predicate<MedicalBill> billFilter;\n    public ConditionalReportVisitor(Predicate<PatientRecord> patientFilter,\n                                   Predicate<Appointment> appointmentFilter,\n                                   Predicate<MedicalBill> billFilter) {\n        this.patientFilter = patientFilter;\n        this.appointmentFilter = appointmentFilter;\n        this.billFilter = billFilter;\n    }\n    @Override\n    public void visit(PatientRecord patient) {\n        if (patientFilter.test(patient)) {\n            // Process patient data\n            processPatientData(patient);\n        }\n    }\n    @Override\n    public void visit(Appointment appointment) {\n        if (appointmentFilter.test(appointment)) {\n            // Process appointment data\n            processAppointmentData(appointment);\n        }\n    }\n    @Override\n    public void visit(MedicalBill bill) {\n        if (billFilter.test(bill)) {\n            // Process bill data\n            processBillData(bill);\n        }\n    }\n    // Usage example:\n    public static ConditionalReportVisitor createHighValuePatientReport() {\n        return new ConditionalReportVisitor(\n            patient -> hasHighValueBilling(patient),\n            appointment -> appointment.getStatus().equals(\"Completed\"),\n            bill -> bill.getAmount() > 1000.0\n        );\n    }\n}","6-usage-scenarios#6. Usage Scenarios":"","61-scenario-1-comprehensive-patient-summary#6.1 Scenario 1: Comprehensive Patient Summary":"// Generate complete patient summary for P001\nString patientId = \"P001\";\nPatientRecord patient = patientDAO.getPatientById(patientId);\n// Create visitor for comprehensive summary\nPatientSummaryReportVisitor visitor = new PatientSummaryReportVisitor();\n// Process patient information\npatient.accept(visitor);\n// Process all patient appointments\nList<Appointment> appointments = schedulingDAO.getAppointmentsByPatientId(patientId);\nappointments.forEach(appointment -> appointment.accept(visitor));\n// Process all patient bills\nList<MedicalBill> bills = billingDAO.getBillsByPatientId(patientId);\nbills.forEach(bill -> bill.accept(visitor));\n// Generate final report\nString report = visitor.getReport();\n// Expected report sections:\n// - Patient Information (demographics, insurance)\n// - Healthcare Summary (appointments, engagement level)\n// - Financial Summary (billing, payments, outstanding)\n// - Service Utilization (most used services)\n// - Doctor Relationships (frequency of visits)\n// - Health Indicators (compliance, service diversity)\n// - Action Items (recommendations)","62-scenario-2-financial-analysis-report#6.2 Scenario 2: Financial Analysis Report":"// Generate detailed financial report for patient\nFinancialReportVisitor financialVisitor = new FinancialReportVisitor();\n// Process the same data through financial lens\npatient.accept(financialVisitor);\nappointments.forEach(appointment -> appointment.accept(financialVisitor));\nbills.forEach(bill -> bill.accept(financialVisitor));\nString financialReport = financialVisitor.getReport();\n// Expected financial analysis:\n// - Total amounts (billed, collected, outstanding)\n// - Payment breakdown (patient vs insurance)\n// - Service revenue analysis\n// - Payment status categorization\n// - Collection rate calculations\n// - Financial recommendations","63-scenario-3-multi-patient-service-utilization#6.3 Scenario 3: Multi-Patient Service Utilization":"// Analyze service utilization across multiple patients\nPatientServiceUtilizationVisitor utilizationVisitor = new PatientServiceUtilizationVisitor();\nList<String> patientIds = Arrays.asList(\"P001\", \"P002\", \"P003\");\nfor (String pid : patientIds) {\n    PatientRecord pt = patientDAO.getPatientById(pid);\n    pt.accept(utilizationVisitor);\n    // Process appointments and bills for each patient\n    schedulingDAO.getAppointmentsByPatientId(pid)\n            .forEach(apt -> apt.accept(utilizationVisitor));\n    billingDAO.getBillsByPatientId(pid)\n            .forEach(bill -> bill.accept(utilizationVisitor));\n}\nString utilizationReport = utilizationVisitor.getReport();\n// Expected utilization analysis:\n// - Service usage patterns per patient\n// - Doctor utilization metrics\n// - Cost per service analysis\n// - Healthcare value indicators\n// - Utilization recommendations","64-scenario-4-doctor-performance-analysis#6.4 Scenario 4: Doctor Performance Analysis":"// Generate doctor performance report across all patients\nDoctorRevenuePerformanceVisitor performanceVisitor = new DoctorRevenuePerformanceVisitor();\n// Process all patients, appointments, and bills\nList<PatientRecord> allPatients = patientDAO.getAllPatients();\nallPatients.forEach(patient -> patient.accept(performanceVisitor));\nList<Appointment> allAppointments = schedulingDAO.getAllAppointments();\nallAppointments.forEach(appointment -> appointment.accept(performanceVisitor));\nList<MedicalBill> allBills = billingDAO.getAllBills();\nallBills.forEach(bill -> bill.accept(performanceVisitor));\nString performanceReport = performanceVisitor.getReport();\n// Expected performance metrics:\n// - Revenue per doctor\n// - Appointment volume by doctor\n// - Collection rates by doctor\n// - Patient load analysis\n// - Performance rankings\n// - Revenue efficiency metrics","7-benefits--trade-offs#7. Benefits & Trade-offs":"","71-visitor-pattern-benefits#7.1 Visitor Pattern Benefits":"Separation of Concerns\nReport generation logic completely separated from domain objects\nDomain objects remain focused on core business functionality\nDifferent report types can be developed independently\nEasy to modify report algorithms without affecting domain model\nExtensibility\nNew report types can be added without modifying existing domain classes\nComplex analytical reports can be implemented as new visitors\nRegulatory reporting requirements easily accommodated\nCustom reports for different stakeholders simple to implement\nCode Reusability\nSame domain objects can be processed by multiple report visitors\nCommon report utilities can be shared across visitor implementations\nData aggregation patterns can be reused in different report contexts\nReport generation workflows are consistent and reusable\nType Safety\nCompile-time checking ensures all visitable types are handled\nMethod overloading provides type-specific processing logic\nNo need for runtime type checking or casting\nClear contracts between visitors and domain objects","72-healthcare-domain-specific-benefits#7.2 Healthcare Domain Specific Benefits":"Regulatory Compliance\nEasy to implement new reporting requirements for changing regulations\nAudit trail capabilities built into report generation process\nStandardized report formats for regulatory submissions\nHistorical reporting capabilities for compliance verification\nMulti-Stakeholder Support\nDifferent report views for clinical staff, administrators, and patients\nFinancial reports for billing departments and insurance companies\nClinical reports for care coordination and quality improvement\nAdministrative reports for operational management\nData Consistency\nReports always based on current domain object state\nNo data duplication between report storage and operational data\nReal-time report generation ensures data accuracy\nConsistent calculations across different report types\nPerformance Optimization\nReports generated on-demand without pre-computation overhead\nEfficient data traversal patterns for large datasets\nMemory-efficient processing through visitor callbacks\nScalable approach for enterprise healthcare systems","73-trade-offs-and-considerations#7.3 Trade-offs and Considerations":"Complexity Management\nLarge number of visitor classes for comprehensive reporting\nComplex interactions between different visitor implementations\nNeed for careful design to avoid visitor explosion\nTesting complexity increases with number of visitors\nPerformance Considerations\nMethod dispatch overhead through visitor interface\nMemory usage can grow with complex report data structures\nLarge datasets may require streaming or pagination approaches\nReport generation time scales with data volume\nMaintenance Overhead\nAdding new domain object types requires updating all visitors\nInterface changes affect all visitor implementations\nVersion compatibility issues between visitors and domain objects\nDocumentation critical for understanding visitor relationships\nLearning Curve\nVisitor pattern can be difficult for developers to understand initially\nComplex report logic may be harder to debug across multiple methods\nRequires good understanding of double dispatch mechanism\nTesting strategies need to account for visitor pattern structure","8-testing--validation#8. Testing & Validation":"","81-unit-testing-individual-visitors#8.1 Unit Testing Individual Visitors":"@Test\npublic void testPatientSummaryReportVisitor() {\n    // Arrange\n    PatientSummaryReportVisitor visitor = new PatientSummaryReportVisitor();\n    PatientRecord patient = new PatientRecord(\"P001\", \"John Doe\");\n    patient.setMedicalHistory(\"Diabetes, Hypertension\");\n    Appointment appointment = new Appointment(\"P001\", \"D001\",\n            LocalDateTime.now(), \"Regular checkup\");\n    appointment.setStatus(\"Completed\");\n    MedicalBill bill = new MedicalBill(\"P001\", \"Consultation\", 150.00);\n    bill.setAmountPaid(30.00);\n    bill.setInsurancePaidAmount(120.00);\n    // Act\n    patient.accept(visitor);\n    appointment.accept(visitor);\n    bill.accept(visitor);\n    String report = visitor.getReport();\n    // Assert\n    assertNotNull(report);\n    assertTrue(report.contains(\"John Doe\"));\n    assertTrue(report.contains(\"P001\"));\n    assertTrue(report.contains(\"Total Appointments: 1\"));\n    assertTrue(report.contains(\"Total Billed: $150.00\"));\n    assertTrue(report.contains(\"Total Collected: $150.00\"));\n    assertTrue(report.contains(\"Outstanding Balance: $0.00\"));\n}\n@Test\npublic void testFinancialReportVisitor() {\n    // Arrange\n    FinancialReportVisitor visitor = new FinancialReportVisitor();\n    PatientRecord patient = new PatientRecord(\"P002\", \"Jane Smith\");\n    MedicalBill bill1 = new MedicalBill(\"P002\", \"Surgery\", 5000.00);\n    bill1.setAmountPaid(1000.00);\n    bill1.setInsurancePaidAmount(3000.00);\n    MedicalBill bill2 = new MedicalBill(\"P002\", \"Follow-up\", 200.00);\n    bill2.setAmountPaid(50.00);\n    bill2.setInsurancePaidAmount(150.00);\n    // Act\n    patient.accept(visitor);\n    bill1.accept(visitor);\n    bill2.accept(visitor);\n    String report = visitor.getReport();\n    // Assert\n    assertTrue(report.contains(\"Total Amount Billed: $5,200.00\"));\n    assertTrue(report.contains(\"Patient Payments: $1,050.00\"));\n    assertTrue(report.contains(\"Insurance Payments: $3,150.00\"));\n    assertTrue(report.contains(\"Total Collected: $4,200.00\"));\n}\n@Test\npublic void testServiceUtilizationVisitor() {\n    // Arrange\n    PatientServiceUtilizationVisitor visitor = new PatientServiceUtilizationVisitor();\n    PatientRecord patient = new PatientRecord(\"P003\", \"Bob Wilson\");\n    // Multiple appointments with same doctor\n    Appointment apt1 = new Appointment(\"P003\", \"D001\", LocalDateTime.now(), \"Checkup\");\n    Appointment apt2 = new Appointment(\"P003\", \"D001\", LocalDateTime.now().plusWeeks(2), \"Follow-up\");\n    // Multiple services\n    MedicalBill bill1 = new MedicalBill(\"P003\", \"Consultation\", 150.00);\n    MedicalBill bill2 = new MedicalBill(\"P003\", \"Consultation\", 150.00);\n    MedicalBill bill3 = new MedicalBill(\"P003\", \"Lab Test\", 75.00);\n    // Act\n    patient.accept(visitor);\n    apt1.accept(visitor);\n    apt2.accept(visitor);\n    bill1.accept(visitor);\n    bill2.accept(visitor);\n    bill3.accept(visitor);\n    String report = visitor.getReport();\n    // Assert\n    assertTrue(report.contains(\"Total Services: 3\"));\n    assertTrue(report.contains(\"Consultation\")); // Most used service\n    assertTrue(report.contains(\"D001\")); // Doctor utilization\n    assertTrue(report.contains(\"Total Billed: $375.00\"));\n}","82-integration-testing-with-multiple-visitors#8.2 Integration Testing with Multiple Visitors":"@Test\npublic void testMultipleVisitorsOnSameData() {\n    // Arrange - Common test data\n    PatientRecord patient = createTestPatient();\n    List<Appointment> appointments = createTestAppointments();\n    List<MedicalBill> bills = createTestBills();\n    // Create different visitors\n    PatientSummaryReportVisitor summaryVisitor = new PatientSummaryReportVisitor();\n    FinancialReportVisitor financialVisitor = new FinancialReportVisitor();\n    PatientServiceUtilizationVisitor utilizationVisitor = new PatientServiceUtilizationVisitor();\n    // Act - Process same data with different visitors\n    List<ReportVisitor> visitors = Arrays.asList(\n            summaryVisitor, financialVisitor, utilizationVisitor);\n    visitors.forEach(visitor -> {\n        patient.accept(visitor);\n        appointments.forEach(apt -> apt.accept(visitor));\n        bills.forEach(bill -> bill.accept(visitor));\n    });\n    // Assert - Different reports generated from same data\n    String summaryReport = summaryVisitor.getReport();\n    String financialReport = financialVisitor.getReport();\n    String utilizationReport = utilizationVisitor.getReport();\n    assertNotEquals(summaryReport, financialReport);\n    assertNotEquals(financialReport, utilizationReport);\n    // Verify each report contains appropriate content\n    assertTrue(summaryReport.contains(\"COMPREHENSIVE PATIENT SUMMARY\"));\n    assertTrue(financialReport.contains(\"FINANCIAL SUMMARY\"));\n    assertTrue(utilizationReport.contains(\"SERVICE UTILIZATION\"));\n}","83-performance-testing#8.3 Performance Testing":"@Test\npublic void testLargeDatasetReportGeneration() {\n    // Arrange - Large dataset\n    List<PatientRecord> patients = createTestPatients(1000);\n    List<Appointment> appointments = createTestAppointments(5000);\n    List<MedicalBill> bills = createTestBills(3000);\n    PatientSummaryReportVisitor visitor = new PatientSummaryReportVisitor();\n    // Act - Measure performance\n    long startTime = System.currentTimeMillis();\n    patients.forEach(patient -> patient.accept(visitor));\n    appointments.forEach(appointment -> appointment.accept(visitor));\n    bills.forEach(bill -> bill.accept(visitor));\n    String report = visitor.getReport();\n    long endTime = System.currentTimeMillis();\n    long duration = endTime - startTime;\n    // Assert - Performance within acceptable limits\n    assertTrue(\"Report generation should complete within 5 seconds\",\n               duration < 5000);\n    assertNotNull(report);\n    assertTrue(\"Report should contain substantial content\",\n               report.length() > 1000);\n}\n@Test\npublic void testMemoryUsageWithLargeReports() {\n    // Test memory efficiency of visitor pattern\n    Runtime runtime = Runtime.getRuntime();\n    long initialMemory = runtime.totalMemory() - runtime.freeMemory();\n    // Generate large report\n    generateLargeReport();\n    long finalMemory = runtime.totalMemory() - runtime.freeMemory();\n    long memoryUsed = finalMemory - initialMemory;\n    // Assert memory usage is reasonable\n    assertTrue(\"Memory usage should be under 100MB\",\n               memoryUsed < 100 * 1024 * 1024);\n}","84-error-handling-testing#8.4 Error Handling Testing":"@Test\npublic void testVisitorWithNullData() {\n    PatientSummaryReportVisitor visitor = new PatientSummaryReportVisitor();\n    // Test null patient\n    assertThrows(NullPointerException.class, () -> {\n        PatientRecord nullPatient = null;\n        nullPatient.accept(visitor);\n    });\n    // Test patient with null fields\n    PatientRecord incompletePatient = new PatientRecord(null, \"Test Name\");\n    assertDoesNotThrow(() -> {\n        incompletePatient.accept(visitor);\n        String report = visitor.getReport();\n        assertNotNull(report);\n    });\n}\n@Test\npublic void testVisitorWithInvalidData() {\n    FinancialReportVisitor visitor = new FinancialReportVisitor();\n    // Test bill with negative amounts\n    MedicalBill invalidBill = new MedicalBill(\"P001\", \"Test Service\", -100.00);\n    assertDoesNotThrow(() -> {\n        invalidBill.accept(visitor);\n        String report = visitor.getReport();\n        // Verify report handles invalid data gracefully\n        assertNotNull(report);\n    });\n}","9-conclusion#9. Conclusion":"The Visitor pattern implementation for medical reports generation demonstrates a sophisticated approach to handling diverse reporting requirements in healthcare systems. The pattern successfully addresses the complex challenges of multi-domain data aggregation while maintaining clean separation between report generation logic and core business objects.","key-achievements#Key Achievements":"Flexible Report Framework: Successfully implements a comprehensive reporting system that can generate diverse report types from the same underlying data\nDomain Separation: Clean separation between business logic and reporting concerns, allowing independent evolution of both\nExtensible Architecture: Easy addition of new report types without modifying existing domain objects or other reports\nComplex Data Analysis: Sophisticated data aggregation and correlation across multiple domain objects (patients, appointments, bills)\nPerformance Scalability: Efficient processing of large datasets through visitor callbacks and streaming approaches","real-world-healthcare-impact#Real-World Healthcare Impact":"The Visitor pattern proves particularly valuable in healthcare reporting contexts where:\nRegulatory Compliance requires diverse reporting formats for different regulatory bodies and timeframes\nMulti-Stakeholder Needs demand different views of the same data for clinical staff, administrators, patients, and insurance companies\nClinical Decision Support benefits from comprehensive patient summaries and utilization analysis\nFinancial Management requires detailed billing analysis and revenue performance tracking\nQuality Improvement needs service utilization patterns and patient engagement metrics","pattern-benefits-realized#Pattern Benefits Realized":"The implementation successfully demonstrates how the Visitor pattern can:\nEnable complex analytical processing without cluttering domain objects with reporting logic\nSupport real-time report generation from current operational data without data duplication\nFacilitate consistent data interpretation across different report types and stakeholders\nProvide type-safe report processing with compile-time verification of visitor completeness\nMaintain high performance even with large datasets through efficient visitor traversal patterns","technical-excellence#Technical Excellence":"The visitor implementation showcases several advanced techniques:\nDouble Dispatch mechanism for type-specific processing\nData Correlation across multiple domain boundaries for comprehensive analysis\nConditional Processing for filtered and targeted report generation\nMemory Efficiency through streaming visitor patterns for large datasets\nError Resilience with graceful handling of incomplete or invalid data\nThe medical reports generation system provides a robust foundation for healthcare analytics while maintaining the flexibility needed for evolving reporting requirements in dynamic healthcare environments.Document Status: Part E CompleteNext: Part F - Security Considerations - Decorator, DAO"}},"/overview":{"title":"System Overview","data":{"foundation--overview-document#Foundation & Overview Document":"Project Name: GlobeMed Healthcare Management SystemRepository: isharax9/healthcare-system | https://github.com/isharax9/healthcare-systemPublished Doc: https://macna.gitbook.io/macna.lk/globemed-hms-docsAuthor: Ishara LakshithaPurpose: Academic/Educational - Design Patterns Implementation","table-of-content#Table Of Content":"","1-project-introduction#1. Project Introduction":"The GlobeMed Healthcare Management System is a comprehensive Java-based desktop application designed to demonstrate advanced software engineering principles through practical implementation of specific design patterns. This system serves as both a functional healthcare management solution and an educational resource for understanding enterprise-level software architecture with targeted pattern implementations.","key-features#Key Features":"Patient Record Management with state restoration using Memento Pattern\nAppointment Scheduling with complex interaction mediation using Mediator Pattern\nBilling & Insurance Processing with flexible workflow using Chain of Responsibility Pattern\nRole-Based Access Control with dynamic permissions using Decorator Pattern\nMedical Report Generation with extensible operations using Visitor Pattern\nSecurity Implementation through multiple complementary patterns","2-system-objectives#2. System Objectives":"","primary-educational-objectives#Primary Educational Objectives":"Targeted Pattern Implementation: Demonstrate real-world application of 6 specific design patterns\nProblem-Solving Architecture: Each module addresses specific healthcare domain problems\nClean Architecture: Showcase proper separation of concerns and layered architecture\nSecurity Through Design: Role-based access control with comprehensive data protection","functional-objectives#Functional Objectives":"Complete Healthcare Workflow: Patient registration to billing completion\nMulti-Role User Support: Doctors, Nurses, and Administrative staff with distinct capabilities\nData Integrity & Recovery: State management with undo functionality\nFlexible Processing: Configurable workflow chains for billing operations\nComprehensive Reporting: Extensible report generation system","3-technology-stack#3. Technology Stack":"","core-technologies#Core Technologies":"Component\tTechnology / Version\tLanguage\tJava\tDevelopment Kit\tJDK 21\tDatabase\tMySQL 9.3.0\tUI Framework\tJava SE Swing\tPDF Generation\tiTextPDF Library, pdfBox Library\tBuild Tool\tApache Maven","dependencies--libraries#Dependencies & Libraries":"<!-- Database Connectivity -->\n<dependency>\n    <groupId>com.mysql</groupId>\n    <artifactId>mysql-connector-j</artifactId>\n    <version>8.2.0</version>\n</dependency>\n<!-- PDF Generation -->\n<dependency>\n    <groupId>com.itextpdf</groupId>\n    <artifactId>itextpdf</artifactId>\n    <version>5.5.13.3</version>\n</dependency>\n<!-- PDF Utilities -->\n<dependency>\n    <groupId>org.apache.pdfbox</groupId>\n    <artifactId>pdfbox</artifactId>\n    <version>2.0.29</version>\n</dependency>","4-architecture-overview#4. Architecture Overview":"","entity-relationship-diagram-eer#Entity-Relationship Diagram (EER)":"","complete-application-uml-class-diagram#Complete Application UML Class Diagram":"(You can find the High Res images in the Github Project Repo)","system-architecture-type#System Architecture Type":"Layered Architecture with Pattern-Specific Module Design\n┌─────────────────────────────────────────┐\n│             Presentation Layer          │\n│     (UI Panels, Controllers, Dialogs)   │\n├─────────────────────────────────────────┤\n│              Business Layer             │\n│  (Pattern Implementations, Domain Logic)│\n├─────────────────────────────────────────┤\n│            Data Access Layer            │\n│         (DAOs, Database Manager)        │\n├─────────────────────────────────────────┤\n│             Database Layer              │\n│          (MySQL Database)               │\n└─────────────────────────────────────────┘","5-system-requirements#5. System Requirements":"","minimum-system-requirements#Minimum System Requirements":"Operating System: Windows 10+, macOS 10.14+, Linux (Ubuntu 18.04+)\nJava Runtime: JRE 21 or higher\nMemory: 4GB RAM minimum, 8GB recommended\nStorage: 100MB for application, 1GB for data\nDatabase: MySQL 8.0+ or MariaDB 10.3+","development-requirements#Development Requirements":"JDK: OpenJDK 21 or Oracle JDK 21+\nBuild Tool: Apache Maven 3.8+\nDatabase: MySQL Server 9.3.0+ with admin privileges\nIDE: IntelliJ IDEA 2023+, Eclipse 2023+, or VS Code with Java extensions","6-project-structure#6. Project Structure":"","package-organization-by-design-pattern#Package Organization by Design Pattern":"com.globemed/\n├── Main.java                           # Application Entry Point\n├── patient/                           # Part A: Memento & Prototype Patterns\n│   ├── PatientRecord.java             # Originator (Memento) + Prototype\n│   ├── PatientRecordMemento.java      # Memento class\n│   └── RecordHistory.java             # Caretaker for undo functionality\n├── appointment/                       # Part B: Mediator Pattern\n│   ├── Appointment.java               # Domain entity\n│   ├── Doctor.java                    # Domain entity\n│   └── AppointmentScheduler.java      # Mediator for complex scheduling\n├── billing/                          # Part C: Chain of Responsibility\n│   ├── MedicalBill.java              # Request object\n│   ├── Handler.java                  # Abstract handler interface\n│   ├── ValidationHandler.java        # Concrete handler\n│   ├── InsuranceHandler.java         # Concrete handler\n│   └── FinalBillingHandler.java      # Concrete handler\n├── auth/                             # Part D: Decorator Pattern\n│   ├── IUser.java                    # Component interface\n│   ├── BaseUser.java                 # Concrete component\n│   ├── UserRoleDecorator.java        # Abstract decorator\n│   ├── DoctorRole.java               # Concrete decorator\n│   ├── AdminRole.java                # Concrete decorator\n│   └── AuthService.java              # Authentication service\n├── reports/                          # Part E: Visitor Pattern\n│   ├── Visitable.java                # Element interface\n│   ├── ReportVisitor.java            # Visitor interface\n│   ├── PatientSummaryReportVisitor.java   # Concrete visitor\n│   ├── FinancialReportVisitor.java        # Concrete visitor\n│   └── AgedReceivablesReportVisitor.java  # Concrete visitor\n├── staff/                            # Supporting entities\n│   └── Staff.java                    # Staff management\n├── insurance/                        # Supporting entities\n│   └── InsurancePlan.java            # Insurance coverage\n├── db/                              # Data Access Layer (DAO Pattern)\n│   ├── DatabaseManager.java         # Connection management\n│   ├── PatientDAO.java              # Patient data operations\n│   ├── SchedulingDAO.java           # Appointment data operations\n│   ├── BillingDAO.java              # Billing data operations\n│   └── StaffDAO.java                # Staff data operations\n├── controller/                      # MVC Controllers\n│   ├── PatientController.java       # Patient management logic\n│   ├── AppointmentController.java   # Appointment management logic\n│   ├── BillingController.java       # Billing management logic\n│   ├── ReportController.java        # Report generation logic\n│   └── StaffController.java         # Staff management logic\n├── ui/                             # User Interface Layer\n│   ├── MainFrame.java              # Main application window\n│   ├── LoginDialog.java            # Authentication interface\n│   ├── PatientPanel.java           # Patient management UI\n│   ├── AppointmentPanel.java       # Appointment management UI\n│   ├── BillingPanel.java           # Billing management UI\n│   ├── ReportPanel.java            # Report generation UI\n│   └── StaffPanel.java             # Staff management UI\n└── utils/                          # Utility Classes\n    ├── BillPrinter.java            # PDF generation utilities\n    └── TextReportPrinter.java      # Report formatting utilities","7-core-application-modules--design-patterns#7. Core Application Modules & Design Patterns":"","71-part-a-patient-record-management#7.1 Part A: Patient Record Management":"Patterns Used: Memento, Prototype\nKey Classes: PatientRecord (Originator), PatientRecordMemento, RecordHistory (Caretaker)\nImplementation:\nMemento pattern captures patient state for undo functionality\nPrototype pattern enables efficient patient template creation\nProblem Solved: State restoration without breaking encapsulation","72-part-b-appointment-scheduling#7.2 Part B: Appointment Scheduling":"Pattern Used: Mediator\nKey Class: AppointmentScheduler (Mediator)\nImplementation:\nCentralizes complex scheduling logic\nManages interactions between Patients, Doctors, and Schedules\nHandles conflict detection and booking validation\nProblem Solved: Reduces coupling between scheduling components","73-part-c-billing-and-insurance-claims#7.3 Part C: Billing and Insurance Claims":"Pattern Used: Chain of Responsibility\nKey Classes: ValidationHandler, InsuranceHandler, FinalBillingHandler\nImplementation:\nMulti-step billing workflow\nEach handler performs specific processing\nFlexible chain configuration\nProblem Solved: Extensible processing pipeline for complex billing rules","74-part-d-managing-medical-staff-roles-and-permissions#7.4 Part D: Managing Medical Staff Roles and Permissions":"Pattern Used: Decorator\nKey Classes: IUser (Component), BaseUser, DoctorRole, AdminRole (Decorators)\nImplementation:\nDynamic permission assignment at runtime\nFlexible role composition\nLayered permission system\nProblem Solved: Role-based access control without rigid inheritance","75-part-e-generating-medical-reports#7.5 Part E: Generating Medical Reports":"Pattern Used: Visitor\nKey Classes: ReportVisitor, PatientSummaryReportVisitor, FinancialReportVisitor\nImplementation:\nSeparates report logic from data models\nExtensible report types\nTraverses object structures for data collection\nProblem Solved: Add new report types without modifying core models","76-part-f-security-considerations#7.6 Part F: Security Considerations":"Patterns Discussed: Decorator, DAO\nImplementation:\nDecorator pattern provides access control foundation\nDAO pattern centralizes database security\nParameterized queries prevent SQL injection\nProblem Solved: Comprehensive security through design patterns","8-getting-started#8. Getting Started":"","81-prerequisites#8.1 Prerequisites":"# Verify Java installation\njava --version  # Should show Java 21+\n# Verify Maven installation\nmvn --version   # Should show Maven 3.8+\n# Verify MySQL installation\nmysql --version # Should show MySQL 8.0+","82-database-setup#8.2 Database Setup":"-- 1. Create database\nCREATE DATABASE globemed_db;\n-- 2. Import schema\nmysql -u root -p globemed_db < globemed_db.sql\n-- 3. Verify tables\nUSE globemed_db;\nSHOW TABLES;","83-application-compilation#8.3 Application Compilation":"# 1. Clone/Extract repository\ncd healthcare-system\n# 2. Compile project\nmvn clean compile\n# 3. Run application\nmvn exec:java -Dexec.mainClass=\"com.globemed.Main\"","84-design-pattern-testing-flow#8.4 Design Pattern Testing Flow":"Patient Management (Memento/Prototype): Create patient → Edit → Use Undo functionality\nAppointment Scheduling (Mediator): Book appointments → Observe conflict resolution\nBilling Processing (Chain of Responsibility): Process bills → See multi-step validation\nRole Management (Decorator): Login with different roles → Observe permission differences\nReport Generation (Visitor): Generate various reports → See extensible report system","85-default-login-credentials#8.5 Default Login Credentials":"Role\tUsername\tPassword\tDesign Pattern Demo\tAdmin\tadmin\t1101\tFull Decorator permissions\tDoctor\tdoc\t1101\tDoctor-specific decorations\tNurse\tnurse\t1101\tLimited permission decorations","9-user-interface-ui-screenshots#9. User Interface (UI) Screenshots":"Please check the published doc to see the UI screenshots.","next-documentation-phases#Next Documentation Phases":"The subsequent documents will provide detailed analysis of each design pattern implementation:\nDocument 02: Part A - Patient Record Management (Memento & Prototype Patterns)\nDocument 03: Part B - Appointment Scheduling (Mediator Pattern)\nDocument 04: Part C - Billing & Insurance Claims (Chain of Responsibility Pattern)\nDocument 05: Part D - Staff Roles & Permissions (Decorator Pattern)\nDocument 06: Part E - Medical Report Generation (Visitor Pattern)\nDocument 07: Part F - Security Implementation & Additional Patterns"}}}